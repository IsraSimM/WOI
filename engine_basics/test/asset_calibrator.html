<!-- Calibrador de assets para enseñarle al chat que no es tan bueno :( -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Asset Calibrator
    </title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js">
    </script>
    <style>
      :root {
        --bg-0: #0b0d12;
        --panel: rgba(16, 21, 29, 0.92);
        --panel-2: rgba(24, 32, 44, 0.92);
        --text: #e7e3d9;
        --muted: #9aa3ad;
        --accent: #f7b32b;
        --shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
      }
      * {
        box-sizing: border-box;
      }
      html, body {
        height: 100%;
        margin: 0;
      }
      body {
        font-family: "Space Grotesk", "Fira Sans", sans-serif;
        background: var(--bg-0);
        color: var(--text);
      }
      .compass-hud {
        position: fixed;
        top: 16px;
        right: 16px;
        width: 96px;
        height: 96px;
        border-radius: 14px;
        background: rgba(16, 21, 29, 0.88);
        border: 1px solid rgba(255, 255, 255, 0.08);
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        place-items: center;
        box-shadow: var(--shadow);
        z-index: 20;
        pointer-events: none;
      }
      .compass-hud span {
        font-size: 12px;
        color: var(--text);
        letter-spacing: 1px;
      }
      .compass-hud .north {
        grid-column: 2;
        grid-row: 1;
        color: #f97316;
      }
      .compass-hud .south {
        grid-column: 2;
        grid-row: 3;
        color: #3b82f6;
      }
      .compass-hud .east {
        grid-column: 3;
        grid-row: 2;
      }
      .compass-hud .west {
        grid-column: 1;
        grid-row: 2;
      }
      .compass-hud .dot {
        grid-column: 2;
        grid-row: 2;
        color: #9aa3ad;
      }
      .app {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 16px;
        padding: 16px;
        height: 100%;
      }
      .panel {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 14px;
        box-shadow: var(--shadow);
        display: grid;
        gap: 12px;
        overflow: auto;
      }
      .panel h1 {
        font-size: 16px;
        margin: 0 0 6px 0;
        letter-spacing: 0.4px;
      }
      .section {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 12px;
        padding: 10px;
        display: grid;
        gap: 8px;
      }
      .section h2 {
        font-size: 11px;
        text-transform: uppercase;
        color: var(--muted);
        letter-spacing: 1px;
        margin: 0 0 6px 0;
      }
      .row {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
        display: grid;
        gap: 6px;
      }
      input, select, button {
        font: inherit;
        color: var(--text);
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 7px 9px;
        width: 100%;
      }
      input[type="checkbox"] {
        width: auto;
      }
      button {
        cursor: pointer;
        background: linear-gradient(135deg, rgba(247, 179, 43, 0.2), rgba(45, 212, 191, 0.18));
        border: 1px solid rgba(247, 179, 43, 0.4);
      }
      button.secondary {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.12);
      }
      .option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
      }
      .option strong {
        font-size: 12px;
      }
      .asset-card canvas {
        width: 120px;
        height: 120px;
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      .asset-head {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .asset-hint {
        font-size: 11px;
        color: var(--muted);
      }
      .legend {
        font-size: 11px;
        color: var(--muted);
      }
      .viewer {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.06);
        box-shadow: var(--shadow);
      }
      .viewer a-scene {
        width: 100%;
        height: 100%;
      }
      .hidden {
        display: none !important;
      }
      .debug-output {
        font-family: "JetBrains Mono", "Fira Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 11px;
        color: #d1d5db;
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 8px;
        max-height: 220px;
        overflow: auto;
        white-space: pre;
      }
      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
        }
        .viewer {
          height: 60vh;
        }
      }
    </style>
  </head>
  <body>
    <div class="compass-hud" aria-hidden="true">
      <span class="north">
        N
      </span>
      <span class="south">
        S
      </span>
      <span class="east">
        E
      </span>
      <span class="west">
        W
      </span>
      <span class="dot">
        •
      </span>
    </div>
    <div class="app">
      <aside class="panel">
        <h1>
          Asset Calibrator
        </h1>
        <div class="section">
          <h2>
            Global
          </h2>
          <div class="row">
            <label>
              Cell size (m)
              <input id="cellSize" type="number" min="0.5" step="0.1" value="6" />
            </label>
            <label>
              Asset size (m)
              <input id="assetSize" type="number" min="0.5" step="0.1" value="6" />
            </label>
          </div>
          <div class="row">
            <label>
              Extra scale
              <input id="wallScale" type="number" min="0.1" step="0.05" value="1" />
            </label>
            <label>
              Origin
              <select id="assetOrigin">
                <option value="center">
                  Center
                </option>
                <option value="base">
                  Base
                </option>
              </select>
            </label>
          </div>
          <div class="option">
            <span>
              Computed scale
            </span>
            <strong id="computedScale">
              1.000
            </strong>
          </div>
          <label>
            Drag mode
            <select id="dragMode">
              <option value="move">
                Move
              </option>
              <option value="rotate">
                Rotate
              </option>
              <option value="scale">
                Scale
              </option>
            </select>
          </label>
          <div class="row">
            <label>
              Ref cube size (m)
              <input id="refCubeSize" type="number" min="0.5" step="0.1" value="6" />
            </label>
            <label>
              Ref cube scale
              <input id="refCubeScale" type="number" min="0.1" step="0.05" value="1" />
            </label>
          </div>
          <div class="option">
            <span>
              Ref cube wireframe
            </span>
            <input id="refCubeWire" type="checkbox" checked />
          </div>
          <div class="row">
            <button id="saveConfig" type="button">
              Guardar config
            </button>
            <button id="resetConfig" type="button" class="secondary">
              Reset config
            </button>
          </div>
          <div class="asset-hint">
            Auto-save activo. Config se guarda en localStorage.
          </div>
          <div class="legend">
            N = -Z, S = +Z, E = +X, W = -X. Azul = no conecta, Naranja = conecta.
          </div>
          <div class="row">
            <button id="simGenerate" type="button">
              Generar simulacion
            </button>
            <label class="option">
              <span>
                Mostrar simulacion
              </span>
              <input id="simEnabled" type="checkbox" />
            </label>
          </div>
          <div class="row">
            <button id="debugUpdate" type="button" class="secondary">
              Actualizar debug
            </button>
            <label class="option">
              <span>
                Mostrar debug
              </span>
              <input id="debugEnabled" type="checkbox" />
            </label>
          </div>
          <div id="debugOutput" class="debug-output hidden">
            Debug desactivado.
          </div>
        </div>
        <div class="section asset-card" data-key="unilateral">
          <h2>
            Unilateral
          </h2>
          <div class="asset-head">
            <canvas class="arrow" width="120" height="120">
            </canvas>
            <div class="asset-hint">
              Azul = no conecta, Naranja = conecta
            </div>
          </div>
          <label>
            Base abierta
            <select class="base-select">
              <option value="N">
                N
              </option>
              <option value="E">
                E
              </option>
              <option value="S" selected>
                S
              </option>
              <option value="W">
                W
              </option>
            </select>
          </label>
          <div class="row">
            <label>
              Pos X
              <input class="pos-x" type="number" step="0.1" value="0" />
            </label>
            <label>
              Pos Y
              <input class="pos-y" type="number" step="0.1" value="0" />
            </label>
          </div>
          <div class="row">
            <label>
              Pos Z
              <input class="pos-z" type="number" step="0.1" value="0" />
            </label>
            <label>
              Rot Y
              <input class="rot-y" type="number" step="1" value="0" />
            </label>
          </div>
          <div class="option">
            <span>
              Bloquear posicion
            </span>
            <input class="lock-move" type="checkbox" />
          </div>
          <label>
            Scale
            <input class="scale" type="number" min="0.1" step="0.05" value="1" />
          </label>
        </div>
        <div class="section asset-card" data-key="bilateral">
          <h2>
            Bilateral
          </h2>
          <div class="asset-head">
            <canvas class="arrow" width="120" height="120">
            </canvas>
            <div class="asset-hint">
              Azul = no conecta, Naranja = conecta
            </div>
          </div>
          <label>
            Base abierta
            <select class="base-select">
              <option value="NS" selected>
                NS
              </option>
              <option value="EW">
                EW
              </option>
            </select>
          </label>
          <div class="row">
            <label>
              Pos X
              <input class="pos-x" type="number" step="0.1" value="0" />
            </label>
            <label>
              Pos Y
              <input class="pos-y" type="number" step="0.1" value="0" />
            </label>
          </div>
          <div class="row">
            <label>
              Pos Z
              <input class="pos-z" type="number" step="0.1" value="0" />
            </label>
            <label>
              Rot Y
              <input class="rot-y" type="number" step="1" value="0" />
            </label>
          </div>
          <div class="option">
            <span>
              Bloquear posicion
            </span>
            <input class="lock-move" type="checkbox" />
          </div>
          <label>
            Scale
            <input class="scale" type="number" min="0.1" step="0.05" value="1" />
          </label>
        </div>
        <div class="section asset-card" data-key="corner">
          <h2>
            Esquina
          </h2>
          <div class="asset-head">
            <canvas class="arrow" width="120" height="120">
            </canvas>
            <div class="asset-hint">
              Azul = no conecta, Naranja = conecta
            </div>
          </div>
          <label>
            Base abierta
            <select class="base-select">
              <option value="NE">
                NE
              </option>
              <option value="SE" selected>
                SE
              </option>
              <option value="SW">
                SW
              </option>
              <option value="NW">
                NW
              </option>
            </select>
          </label>
          <div class="row">
            <label>
              Pos X
              <input class="pos-x" type="number" step="0.1" value="0" />
            </label>
            <label>
              Pos Y
              <input class="pos-y" type="number" step="0.1" value="0" />
            </label>
          </div>
          <div class="row">
            <label>
              Pos Z
              <input class="pos-z" type="number" step="0.1" value="0" />
            </label>
            <label>
              Rot Y
              <input class="rot-y" type="number" step="1" value="0" />
            </label>
          </div>
          <div class="option">
            <span>
              Bloquear posicion
            </span>
            <input class="lock-move" type="checkbox" />
          </div>
          <label>
            Scale
            <input class="scale" type="number" min="0.1" step="0.05" value="1" />
          </label>
        </div>
        <div class="section asset-card" data-key="trilateral">
          <h2>
            Trilateral
          </h2>
          <div class="asset-head">
            <canvas class="arrow" width="120" height="120">
            </canvas>
            <div class="asset-hint">
              Azul = no conecta, Naranja = conecta
            </div>
          </div>
          <label>
            Lados abiertos
            <select class="base-select">
              <option value="NSW">
                NSW
              </option>
              <option value="NSE" selected>
                NSE
              </option>
              <option value="WES">
                WES
              </option>
              <option value="WEN">
                WEN
              </option>
            </select>
          </label>
          <div class="row">
            <label>
              Pos X
              <input class="pos-x" type="number" step="0.1" value="0" />
            </label>
            <label>
              Pos Y
              <input class="pos-y" type="number" step="0.1" value="0" />
            </label>
          </div>
          <div class="row">
            <label>
              Pos Z
              <input class="pos-z" type="number" step="0.1" value="0" />
            </label>
            <label>
              Rot Y
              <input class="rot-y" type="number" step="1" value="0" />
            </label>
          </div>
          <div class="option">
            <span>
              Bloquear posicion
            </span>
            <input class="lock-move" type="checkbox" />
          </div>
          <label>
            Scale
            <input class="scale" type="number" min="0.1" step="0.05" value="1" />
          </label>
        </div>
        <div class="section asset-card" data-key="full">
          <h2>
            Completo
          </h2>
          <div class="asset-head">
            <canvas class="arrow" width="120" height="120">
            </canvas>
            <div class="asset-hint">
              Azul = no conecta, Naranja = conecta
            </div>
          </div>
          <div class="row">
            <label>
              Pos X
              <input class="pos-x" type="number" step="0.1" value="0" />
            </label>
            <label>
              Pos Y
              <input class="pos-y" type="number" step="0.1" value="0" />
            </label>
          </div>
          <div class="row">
            <label>
              Pos Z
              <input class="pos-z" type="number" step="0.1" value="0" />
            </label>
            <label>
              Rot Y
              <input class="rot-y" type="number" step="1" value="0" />
            </label>
          </div>
          <div class="option">
            <span>
              Bloquear posicion
            </span>
            <input class="lock-move" type="checkbox" />
          </div>
          <label>
            Scale
            <input class="scale" type="number" min="0.1" step="0.05" value="1" />
          </label>
        </div>
      </aside>
      <section class="viewer">
        <a-scene background="color: #9aa0a6" renderer="antialias: true; colorManagement: true;" embedded>
          <a-assets>
            <a-asset-item id="mdl-unilateral" src="../assets/unilateral.glb">
            </a-asset-item>
            <a-asset-item id="mdl-bilateral" src="../assets/bilateral.glb">
            </a-asset-item>
            <a-asset-item id="mdl-corner" src="../assets/bilateral_corner.glb">
            </a-asset-item>
            <a-asset-item id="mdl-trilateral" src="../assets/trilateral.glb">
            </a-asset-item>
            <a-asset-item id="mdl-full" src="../assets/full.glb">
            </a-asset-item>
          </a-assets>
          <a-entity id="rig" position="0 6 20">
            <a-entity camera look-controls wasd-controls="acceleration: 40; fly: true"              cursor="rayOrigin: mouse" raycaster="objects: .draggable">
            </a-entity>
          </a-entity>
          <a-entity light="type: ambient; intensity: 0.6">
          </a-entity>
          <a-entity light="type: directional; intensity: 0.8" position="6 10 4">
          </a-entity>
          <a-plane id="floor" rotation="-90 0 0" width="80" height="80" color="#cfd2d6">
          </a-plane>
          <a-entity id="slot-unilateral" class="slot" data-key="unilateral" position="-28 0 0">
            <a-box class="ref-cube" width="6" height="6" depth="6"              material="color: #f7b32b; wireframe: true; opacity: 0.4; transparent: true">
            </a-box>
            <a-plane class="face-marker" data-side="N">
            </a-plane>
            <a-plane class="face-marker" data-side="E">
            </a-plane>
            <a-plane class="face-marker" data-side="S">
            </a-plane>
            <a-plane class="face-marker" data-side="W">
            </a-plane>
            <a-entity class="compass">
              <a-text class="dir-label" data-side="N" value="N" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="E" value="E" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="S" value="S" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="W" value="W" color="#e7e3d9" align="center">
              </a-text>
            </a-entity>
            <a-entity id="asset-unilateral" class="draggable" data-key="unilateral" gltf-model="#mdl-unilateral">
            </a-entity>
          </a-entity>
          <a-entity id="slot-bilateral" class="slot" data-key="bilateral" position="-14 0 0">
            <a-box class="ref-cube" width="6" height="6" depth="6"              material="color: #f7b32b; wireframe: true; opacity: 0.4; transparent: true">
            </a-box>
            <a-plane class="face-marker" data-side="N">
            </a-plane>
            <a-plane class="face-marker" data-side="E">
            </a-plane>
            <a-plane class="face-marker" data-side="S">
            </a-plane>
            <a-plane class="face-marker" data-side="W">
            </a-plane>
            <a-entity class="compass">
              <a-text class="dir-label" data-side="N" value="N" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="E" value="E" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="S" value="S" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="W" value="W" color="#e7e3d9" align="center">
              </a-text>
            </a-entity>
            <a-entity id="asset-bilateral" class="draggable" data-key="bilateral" gltf-model="#mdl-bilateral">
            </a-entity>
          </a-entity>
          <a-entity id="slot-corner" class="slot" data-key="corner" position="0 0 0">
            <a-box class="ref-cube" width="6" height="6" depth="6"              material="color: #f7b32b; wireframe: true; opacity: 0.4; transparent: true">
            </a-box>
            <a-plane class="face-marker" data-side="N">
            </a-plane>
            <a-plane class="face-marker" data-side="E">
            </a-plane>
            <a-plane class="face-marker" data-side="S">
            </a-plane>
            <a-plane class="face-marker" data-side="W">
            </a-plane>
            <a-entity class="compass">
              <a-text class="dir-label" data-side="N" value="N" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="E" value="E" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="S" value="S" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="W" value="W" color="#e7e3d9" align="center">
              </a-text>
            </a-entity>
            <a-entity id="asset-corner" class="draggable" data-key="corner" gltf-model="#mdl-corner">
            </a-entity>
          </a-entity>
          <a-entity id="slot-trilateral" class="slot" data-key="trilateral" position="14 0 0">
            <a-box class="ref-cube" width="6" height="6" depth="6"              material="color: #f7b32b; wireframe: true; opacity: 0.4; transparent: true">
            </a-box>
            <a-plane class="face-marker" data-side="N">
            </a-plane>
            <a-plane class="face-marker" data-side="E">
            </a-plane>
            <a-plane class="face-marker" data-side="S">
            </a-plane>
            <a-plane class="face-marker" data-side="W">
            </a-plane>
            <a-entity class="compass">
              <a-text class="dir-label" data-side="N" value="N" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="E" value="E" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="S" value="S" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="W" value="W" color="#e7e3d9" align="center">
              </a-text>
            </a-entity>
            <a-entity id="asset-trilateral" class="draggable" data-key="trilateral" gltf-model="#mdl-trilateral">
            </a-entity>
          </a-entity>
          <a-entity id="slot-full" class="slot" data-key="full" position="28 0 0">
            <a-box class="ref-cube" width="6" height="6" depth="6"              material="color: #f7b32b; wireframe: true; opacity: 0.4; transparent: true">
            </a-box>
            <a-plane class="face-marker" data-side="N">
            </a-plane>
            <a-plane class="face-marker" data-side="E">
            </a-plane>
            <a-plane class="face-marker" data-side="S">
            </a-plane>
            <a-plane class="face-marker" data-side="W">
            </a-plane>
            <a-entity class="compass">
              <a-text class="dir-label" data-side="N" value="N" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="E" value="E" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="S" value="S" color="#e7e3d9" align="center">
              </a-text>
              <a-text class="dir-label" data-side="W" value="W" color="#e7e3d9" align="center">
              </a-text>
            </a-entity>
            <a-entity id="asset-full" class="draggable" data-key="full" gltf-model="#mdl-full">
            </a-entity>
          </a-entity>
          <a-entity id="simulation" position="0 0 -24">
          </a-entity>
          <a-text id="southLabel" value="S" color="#e7e3d9" align="center"            position="0 0.03 18" rotation="-90 0 0" scale="2 2 2">
          </a-text>
        </a-scene>
      </section>
    </div>
    <script>
      const CALIB_KEY = 'mazeAssetCalibration';
      const SIDE = {
        N: 1, E: 2, S: 4, W: 8
      };
      const ALL_SIDES = SIDE.N | SIDE.E | SIDE.S | SIDE.W;
      const ASSET_KEYS = ['unilateral', 'bilateral', 'corner', 'trilateral', 'full'];
      const TRILATERAL_OPTIONS = [        {
        label: 'NSW', open: SIDE.N | SIDE.S | SIDE.W
      },        {
        label: 'NSE', open: SIDE.N | SIDE.S | SIDE.E
      },        {
        label: 'WES', open: SIDE.W | SIDE.E | SIDE.S
      },        {
        label: 'WEN', open: SIDE.W | SIDE.E | SIDE.N
      },      ];
      const ui = {
        cellSize: document.getElementById('cellSize'),        assetSize: document.getElementById('assetSize'),        wallScale: document.getElementById('wallScale'),        assetOrigin: document.getElementById('assetOrigin'),        computedScale: document.getElementById('computedScale'),        dragMode: document.getElementById('dragMode'),        refCubeSize: document.getElementById('refCubeSize'),        refCubeScale: document.getElementById('refCubeScale'),        refCubeWire: document.getElementById('refCubeWire'),        saveConfig: document.getElementById('saveConfig'),        resetConfig: document.getElementById('resetConfig'),        simEnabled: document.getElementById('simEnabled'),        simGenerate: document.getElementById('simGenerate'),        debugEnabled: document.getElementById('debugEnabled'),        debugUpdate: document.getElementById('debugUpdate'),        debugOutput: document.getElementById('debugOutput'),
      };
      const slots = {
        unilateral: document.getElementById('slot-unilateral'),        bilateral: document.getElementById('slot-bilateral'),        corner: document.getElementById('slot-corner'),        trilateral: document.getElementById('slot-trilateral'),        full: document.getElementById('slot-full'),
      };
      const assets = {
        unilateral: document.getElementById('asset-unilateral'),        bilateral: document.getElementById('asset-bilateral'),        corner: document.getElementById('asset-corner'),        trilateral: document.getElementById('asset-trilateral'),        full: document.getElementById('asset-full'),
      };
      const simulationEl = document.getElementById('simulation');
      const simulationClones = {
        unilateral: [],        bilateral: [],        corner: [],        trilateral: [],        full: [],
      };
      let simulationBuilt = false;
      let debugPending = false;
      const slotMarkers = {
      };
      document.querySelectorAll('.slot').forEach((slot) => {
        const key = slot.dataset.key;
        if (!key) return;
        slotMarkers[key] = {
          faces: {
            N: slot.querySelector('.face-marker[data-side="N"]'),            E: slot.querySelector('.face-marker[data-side="E"]'),            S: slot.querySelector('.face-marker[data-side="S"]'),            W: slot.querySelector('.face-marker[data-side="W"]'),
          },          labels: {
            N: slot.querySelector('.dir-label[data-side="N"]'),            E: slot.querySelector('.dir-label[data-side="E"]'),            S: slot.querySelector('.dir-label[data-side="S"]'),            W: slot.querySelector('.dir-label[data-side="W"]'),
          },
        };
      });
      const assetUI = {
      };
      document.querySelectorAll('.asset-card').forEach((card) => {
        const key = card.dataset.key;
        assetUI[key] = {
          card,          arrow: card.querySelector('canvas.arrow'),          base: card.querySelector('select.base-select'),          posX: card.querySelector('.pos-x'),          posY: card.querySelector('.pos-y'),          posZ: card.querySelector('.pos-z'),          rotY: card.querySelector('.rot-y'),          lockMove: card.querySelector('.lock-move'),          scale: card.querySelector('.scale'),
        };
      });
      const defaultConfig = () => ({
        version: 1,        cellSize: 6,        assetSize: 6,        wallScale: 1,        assetOrigin: 'center',        base: {
          unilateral: 'S',          bilateral: 'NS',          corner: 'SE',          trilateral: 'NSE',
        },        adjust: {
          unilateral: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1, lockMove: false
          },          bilateral: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1, lockMove: false
          },          corner: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1, lockMove: false
          },          trilateral: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1, lockMove: false
          },          full: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1, lockMove: false
          },
        },        refCube: {
          size: 6, scale: 1, wire: true
        },
      });
      function loadConfig() {
        try {
          const raw = localStorage.getItem(CALIB_KEY);
          if (!raw) return null;
          const cfg = JSON.parse(raw);
          return cfg && typeof cfg === 'object' ? cfg : null;
        }
        catch {
          return null;
        }
      }
      const config = Object.assign(defaultConfig(), loadConfig() || {
      });
      config.base = Object.assign({
      }, defaultConfig().base, config.base || {
      });
      config.base.trilateral = normalizeTrilateralBase(config.base.trilateral);
      function saveConfig() {
        localStorage.setItem(CALIB_KEY, JSON.stringify(config));
      }
      function parseNumber(el, fallback, min = -Infinity, max = Infinity) {
        const v = Number(el.value);
        if (!Number.isFinite(v)) return fallback;
        return Math.max(min, Math.min(max, v));
      }
      function parseTrilateralBase(value) {
        const raw = String(value ?? '').toUpperCase();
        let openMask = 0;
        if (raw.length === 1 && SIDE[raw]) {
          openMask = ALL_SIDES & ~SIDE[raw];
        }
        else {
          for (const ch of raw) {
            if (SIDE[ch]) openMask |= SIDE[ch];
          }
        }
        if (!openMask) openMask = TRILATERAL_OPTIONS[1].open;
        const match = TRILATERAL_OPTIONS.find((opt) => opt.open === openMask);
        const label = match ? match.label : TRILATERAL_OPTIONS[1].label;
        return {
          openMask, closedMask: ALL_SIDES & ~openMask, label
        };
      }
      function normalizeTrilateralBase(value) {
        return parseTrilateralBase(value).label;
      }
      function computeGlobalScale() {
        const assetSize = Math.max(0.01, config.assetSize);
        return (config.cellSize / assetSize) * config.wallScale;
      }
      function baseY() {
        const size = config.cellSize * config.wallScale;
        return config.assetOrigin === 'center' ? size * 0.5 : 0;
      }
      function calcLocalOffset(key, yaw) {
        const adj = config.adjust[key] || {
        };
        const y = baseY() + (adj.pos?.y || 0);
        const ox = adj.pos?.x || 0;
        const oz = adj.pos?.z || 0;
        const rad = (yaw || 0) * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        const rx = (ox * cos) + (oz * sin);
        const rz = (-ox * sin) + (oz * cos);
        return {
          x: rx, y, z: rz
        };
      }
      function maskToSides(mask) {
        let s = '';
        if (mask & SIDE.N) s += 'N';
        if (mask & SIDE.E) s += 'E';
        if (mask & SIDE.S) s += 'S';
        if (mask & SIDE.W) s += 'W';
        return s || '-';
      }
      function normalizeConfig() {
        config.cellSize = parseNumber(ui.cellSize, config.cellSize, 0.1);
        config.assetSize = parseNumber(ui.assetSize, config.assetSize, 0.1);
        config.wallScale = parseNumber(ui.wallScale, config.wallScale, 0.01);
        config.assetOrigin = ui.assetOrigin.value || 'center';
        config.refCube = config.refCube || {
          size: 6, scale: 1, wire: true
        };
        config.refCube.size = parseNumber(ui.refCubeSize, config.refCube.size, 0.1);
        config.refCube.scale = parseNumber(ui.refCubeScale, config.refCube.scale, 0.1);
        config.refCube.wire = ui.refCubeWire.checked;
        ui.computedScale.textContent = computeGlobalScale().toFixed(3);
      }
      function applyGlobalToUI() {
        ui.cellSize.value = config.cellSize;
        ui.assetSize.value = config.assetSize;
        ui.wallScale.value = config.wallScale;
        ui.assetOrigin.value = config.assetOrigin;
        ui.refCubeSize.value = config.refCube?.size ?? 6;
        ui.refCubeScale.value = config.refCube?.scale ?? 1;
        ui.refCubeWire.checked = config.refCube?.wire ?? true;
      }
      function updateRefCubes() {
        const size = config.refCube?.size ?? 6;
        const scale = config.refCube?.scale ?? 1;
        const wire = config.refCube?.wire ?? true;
        const half = (size * scale) * 0.5;
        const faceSize = Math.max(0.5, size * scale * 0.45);
        const labelOffset = Math.max(0.8, size * scale * 0.7);
        document.querySelectorAll('.ref-cube').forEach((cube) => {
          cube.setAttribute('width', size);
          cube.setAttribute('height', size);
          cube.setAttribute('depth', size);
          cube.object3D.scale.set(scale, scale, scale);
          cube.setAttribute('material', `color: #f7b32b; wireframe: ${wire}; opacity: 0.4; transparent: true`);
          cube.object3D.position.set(0, (size * scale) * 0.5, 0);
        });
        Object.keys(slotMarkers).forEach((key) => {
          const faces = slotMarkers[key].faces;
          const labels = slotMarkers[key].labels;
          const setPlane = (el, x, y, z, rotY) => {
            if (!el) return;
            el.setAttribute('width', faceSize);
            el.setAttribute('height', faceSize);
            el.setAttribute('position', `${x} ${y} ${z}`);
            el.setAttribute('rotation', `0 ${rotY} 0`);
          };
          const y = half;
          setPlane(faces.N, 0, y, -half - 0.05, 180);
          setPlane(faces.S, 0, y, half + 0.05, 0);
          setPlane(faces.E, half + 0.05, y, 0, -90);
          setPlane(faces.W, -half - 0.05, y, 0, 90);
          const setLabel = (el, x, z, rotY) => {
            if (!el) return;
            el.setAttribute('position', `${x} 0.05 ${z}`);
            el.setAttribute('rotation', `-90 ${rotY} 0`);
            el.setAttribute('scale', '1 1 1');
          };
          setLabel(labels.N, 0, -labelOffset, 0);
          setLabel(labels.S, 0, labelOffset, 180);
          setLabel(labels.E, labelOffset, 0, -90);
          setLabel(labels.W, -labelOffset, 0, 90);
        });
      }
      function applyAssetTransform(key) {
        const el = assets[key];
        if (!el) return;
        const adj = config.adjust[key];
        const gScale = computeGlobalScale();
        const y = baseY() + (adj.pos?.y || 0);
        el.object3D.position.set(adj.pos?.x || 0, y, adj.pos?.z || 0);
        el.object3D.rotation.set(0, THREE.MathUtils.degToRad(adj.rotY || 0), 0);
        const s = gScale * (adj.scale || 1);
        el.object3D.scale.set(s, s, s);
      }
      function applyTransformToEntity(el, key, yaw, openMask) {
        if (!el) return;
        const adj = config.adjust[key];
        const gScale = computeGlobalScale();
        const y = baseY() + (adj.pos?.y || 0);
        const ox = adj.pos?.x || 0;
        const oz = adj.pos?.z || 0;
        const rad = (yaw || 0) * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        const rx = (ox * cos) + (oz * sin);
        const rz = (-ox * sin) + (oz * cos);
        el.object3D.position.set(rx, y, rz);
        el.object3D.rotation.set(0, THREE.MathUtils.degToRad((yaw || 0) + (adj.rotY || 0)), 0);
        const s = gScale * (adj.scale || 1);
        el.object3D.scale.set(s, s, s);
        if (openMask != null) {
          el.setAttribute('data-openmask', String(openMask));
        }
      }
      function syncAssetInputs(key) {
        const adj = config.adjust[key];
        const uiCard = assetUI[key];
        if (!uiCard || !adj) return;
        uiCard.posX.value = (adj.pos?.x || 0).toFixed(2);
        uiCard.posY.value = (adj.pos?.y || 0).toFixed(2);
        uiCard.posZ.value = (adj.pos?.z || 0).toFixed(2);
        uiCard.rotY.value = (adj.rotY || 0).toFixed(1);
        uiCard.scale.value = (adj.scale || 1).toFixed(2);
        if (uiCard.lockMove) uiCard.lockMove.checked = !!adj.lockMove;
      }
      function baseOpenMask(key, base) {
        if (key === 'unilateral') return SIDE[base] || SIDE.S;
        if (key === 'bilateral') return base === 'EW' ? (SIDE.E | SIDE.W) : (SIDE.N | SIDE.S);
        if (key === 'corner') {
          if (base === 'NE') return SIDE.N | SIDE.E;
          if (base === 'SE') return SIDE.S | SIDE.E;
          if (base === 'SW') return SIDE.S | SIDE.W;
          return SIDE.N | SIDE.W;
        }
        if (key === 'trilateral') {
          return parseTrilateralBase(base).openMask;
        }
        return ALL_SIDES;
      }
      function closedMaskFor(key, base) {
        if (key === 'full') return 0;
        if (key === 'trilateral') return parseTrilateralBase(base).closedMask;
        const open = baseOpenMask(key, base);
        return ALL_SIDES & ~open;
      }
      function rotateMask(mask, steps) {
        let m = mask;
        for (let i = 0;
        i < steps;
        i++) {
          let next = 0;
          if (m & SIDE.N) next |= SIDE.E;
          if (m & SIDE.E) next |= SIDE.S;
          if (m & SIDE.S) next |= SIDE.W;
          if (m & SIDE.W) next |= SIDE.N;
          m = next;
        }
        return m;
      }
      function yawForMask(mask, baseMask) {
        for (let k = 0;
        k < 4;
        k++) {
          if (rotateMask(baseMask, k) === mask) return (-k * 90);
        }
        return 0;
      }
      function maskForVariant(key, variant) {
        if (key === 'unilateral') return SIDE[variant] || SIDE.S;
        if (key === 'bilateral') return variant === 'EW' ? (SIDE.E | SIDE.W) : (SIDE.N | SIDE.S);
        if (key === 'corner') {
          if (variant === 'NE') return SIDE.N | SIDE.E;
          if (variant === 'SE') return SIDE.S | SIDE.E;
          if (variant === 'SW') return SIDE.S | SIDE.W;
          return SIDE.N | SIDE.W;
        }
        if (key === 'trilateral') {
          return parseTrilateralBase(variant).openMask;
        }
        return ALL_SIDES;
      }
      function drawArrow(canvas, closedMask, rotY) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#0f141d';
        ctx.fillRect(0, 0, w, h);
        ctx.save();
        ctx.translate(w / 2, h / 2);
        ctx.rotate((rotY || 0) * Math.PI / 180);
        ctx.translate(-w / 2, -h / 2);
        const pad = 16;
        const left = pad;
        const top = pad;
        const size = w - pad * 2;
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        ctx.strokeRect(left, top, size, size);
        const drawEdge = (x1, y1, x2, y2, closed) => {
          ctx.strokeStyle = closed ? '#f97316' : '#3b82f6';
          ctx.lineWidth = closed ? 4 : 3;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          if (!closed) return;
          const angle = Math.atan2(y2 - y1, x2 - x1);
          const head = 6;
          ctx.beginPath();
          ctx.moveTo(x2, y2);
          ctx.lineTo(x2 - head * Math.cos(angle - 0.6), y2 - head * Math.sin(angle - 0.6));
          ctx.lineTo(x2 - head * Math.cos(angle + 0.6), y2 - head * Math.sin(angle + 0.6));
          ctx.closePath();
          ctx.fillStyle = '#f97316';
          ctx.fill();
        };
        const cx = left + size / 2;
        const cy = top + size / 2;
        drawEdge(left, top, left + size, top, (closedMask & SIDE.N));
        drawEdge(left, top + size, left + size, top + size, (closedMask & SIDE.S));
        drawEdge(left + size, top, left + size, top + size, (closedMask & SIDE.E));
        drawEdge(left, top, left, top + size, (closedMask & SIDE.W));
        ctx.restore();
      }
      function updateArrow(key) {
        const uiCard = assetUI[key];
        if (!uiCard) return;
        const base = config.base[key] || uiCard.base?.value || 'S';
        const closed = closedMaskFor(key, base);
        drawArrow(uiCard.arrow, closed, config.adjust[key]?.rotY || 0);
      }
      function updateFaceMarkers() {
        Object.keys(slotMarkers).forEach((key) => {
          const base = config.base[key] || assetUI[key]?.base?.value || 'S';
          const closed = closedMaskFor(key, base);
          const faces = slotMarkers[key].faces;
          const setFace = (side, mask) => {
            const el = faces[side];
            if (!el) return;
            const isClosed = (mask & SIDE[side]) !== 0;
            const color = isClosed ? '#f97316' : '#3b82f6';
            const opacity = isClosed ? 0.85 : 0.22;
            el.setAttribute('material', `color: ${color}; opacity: ${opacity}; transparent: true`);
          };
          setFace('N', closed);
          setFace('E', closed);
          setFace('S', closed);
          setFace('W', closed);
        });
      }
      function buildSimulation() {
        if (!simulationEl) return;
        simulationEl.innerHTML = '';
        Object.keys(simulationClones).forEach((k) => {
          simulationClones[k] = [];
        });
        simulationBuilt = true;
        const spacing = Math.max(4, config.cellSize * 1.8);
        const rows = [          {
          key: 'unilateral', variants: ['N', 'E', 'S', 'W']
        },          {
          key: 'bilateral', variants: ['NS', 'EW']
        },          {
          key: 'corner', variants: ['NE', 'SE', 'SW', 'NW']
        },          {
          key: 'trilateral', variants: TRILATERAL_OPTIONS.map((opt) => opt.label)
        },          {
          key: 'full', variants: ['ALL']
        },        ];
        const label = document.createElement('a-text');
        label.setAttribute('value', 'SIMULACION');
        label.setAttribute('position', `0 3 ${spacing}`);
        label.setAttribute('align', 'center');
        label.setAttribute('color', '#e7e3d9');
        simulationEl.appendChild(label);
        const compass = document.createElement('a-entity');
        const compassLabels = [          {
          value: 'N', x: 0, z: -spacing * 0.8
        },          {
          value: 'S', x: 0, z: spacing * 0.8
        },          {
          value: 'E', x: spacing * 0.8, z: 0
        },          {
          value: 'W', x: -spacing * 0.8, z: 0
        },        ];
        compassLabels.forEach((c) => {
          const t = document.createElement('a-text');
          t.setAttribute('value', c.value);
          t.setAttribute('color', '#e7e3d9');
          t.setAttribute('align', 'center');
          t.setAttribute('position', `${c.x} 0.02 ${c.z}`);
          t.setAttribute('rotation', '-90 0 0');
          compass.appendChild(t);
        });
        simulationEl.appendChild(compass);
        rows.forEach((row, r) => {
          const count = row.variants.length;
          const startX = -((count - 1) * spacing) / 2;
          row.variants.forEach((variant, c) => {
            const cell = document.createElement('a-entity');
            const x = startX + c * spacing;
            const z = -r * spacing;
            cell.setAttribute('position', `${x} 0 ${z}`);
            const tile = document.createElement('a-plane');
            tile.setAttribute('width', config.cellSize * 1.1);
            tile.setAttribute('height', config.cellSize * 1.1);
            tile.setAttribute('rotation', '-90 0 0');
            tile.setAttribute('color', '#1b212b');
            tile.setAttribute('opacity', '0.5');
            cell.appendChild(tile);
            const info = document.createElement('a-text');
            info.setAttribute('value', `${row.key}:${variant}`);
            info.setAttribute('position', `0 2.4 0`);
            info.setAttribute('align', 'center');
            info.setAttribute('color', '#e7e3d9');
            cell.appendChild(info);
            const model = document.createElement('a-entity');
            let id = '#mdl-full';
            if (row.key === 'unilateral') id = '#mdl-unilateral';
            else if (row.key === 'bilateral') id = '#mdl-bilateral';
            else if (row.key === 'corner') id = '#mdl-corner';
            else if (row.key === 'trilateral') id = '#mdl-trilateral';
            model.setAttribute('gltf-model', id);
            cell.appendChild(model);
            const openMask = row.key === 'full' ? ALL_SIDES : maskForVariant(row.key, variant);
            simulationClones[row.key].push({
              el: model, openMask, variant, cell
            });
            const closedMask = ALL_SIDES & ~openMask;
            const dirLabels = [              {
              side: 'N', x: 0, z: -config.cellSize * 0.7
            },              {
              side: 'S', x: 0, z: config.cellSize * 0.7
            },              {
              side: 'E', x: config.cellSize * 0.7, z: 0
            },              {
              side: 'W', x: -config.cellSize * 0.7, z: 0
            },            ];
            dirLabels.forEach((d) => {
              const t = document.createElement('a-text');
              const closed = (closedMask & SIDE[d.side]) !== 0;
              t.setAttribute('value', d.side);
              t.setAttribute('color', closed ? '#f97316' : '#3b82f6');
              t.setAttribute('align', 'center');
              t.setAttribute('position', `${d.x} 0.05 ${d.z}`);
              t.setAttribute('rotation', '-90 0 0');
              cell.appendChild(t);
            });
            simulationEl.appendChild(cell);
          });
        });
      }
      function updateSimulationTransforms() {
        if (!simulationBuilt) return;
        Object.keys(simulationClones).forEach((key) => {
          const base = config.base[key] || assetUI[key]?.base?.value || 'S';
          const baseMask = baseOpenMask(key, base);
          simulationClones[key].forEach((item) => {
            const yaw = yawForMask(item.openMask, baseMask);
            applyTransformToEntity(item.el, key, yaw, item.openMask);
          });
        });
        scheduleDebugUpdate();
      }
      function updateDebugOutput() {
        if (!ui.debugOutput) return;
        if (!ui.debugEnabled?.checked) {
          ui.debugOutput.classList.add('hidden');
          ui.debugOutput.textContent = 'Debug desactivado.';
          return;
        }
        ui.debugOutput.classList.remove('hidden');
        if (!simulationBuilt) {
          ui.debugOutput.textContent = 'Simulacion no generada.';
          return;
        }
        const lines = [];
        const temp = new THREE.Vector3();
        const tempCell = new THREE.Vector3();
        Object.keys(simulationClones).forEach((key) => {
          const base = config.base[key] || assetUI[key]?.base?.value || 'S';
          const baseMask = baseOpenMask(key, base);
          simulationClones[key].forEach((item) => {
            const yaw = yawForMask(item.openMask, baseMask);
            const expectedLocal = calcLocalOffset(key, yaw);
            const actualLocal = item.el?.object3D?.position || {
              x: 0, y: 0, z: 0
            };
            const cellWorld = item.cell?.object3D?.getWorldPosition(tempCell) || tempCell.set(0, 0, 0);
            const expectedWorld = {
              x: cellWorld.x + expectedLocal.x,              y: cellWorld.y + expectedLocal.y,              z: cellWorld.z + expectedLocal.z,
            };
            const actualWorld = item.el?.object3D?.getWorldPosition(temp) || temp.set(0, 0, 0);
            const diff = {
              x: actualWorld.x - expectedWorld.x,              y: actualWorld.y - expectedWorld.y,              z: actualWorld.z - expectedWorld.z,
            };
            lines.push(              `[${key}:${item.variant}] yaw=${yaw} base=${base} open=${maskToSides(item.openMask)} ` +              `expL=(${expectedLocal.x.toFixed(2)},${expectedLocal.y.toFixed(2)},${expectedLocal.z.toFixed(2)}) ` +              `actL=(${actualLocal.x.toFixed(2)},${actualLocal.y.toFixed(2)},${actualLocal.z.toFixed(2)}) ` +              `expW=(${expectedWorld.x.toFixed(2)},${expectedWorld.y.toFixed(2)},${expectedWorld.z.toFixed(2)}) ` +              `actW=(${actualWorld.x.toFixed(2)},${actualWorld.y.toFixed(2)},${actualWorld.z.toFixed(2)}) ` +              `diff=(${diff.x.toFixed(2)},${diff.y.toFixed(2)},${diff.z.toFixed(2)})`            );
          });
        });
        ui.debugOutput.textContent = lines.join('\n');
      }
      function scheduleDebugUpdate() {
        if (!ui.debugEnabled?.checked) return;
        if (debugPending) return;
        debugPending = true;
        requestAnimationFrame(() => {
          debugPending = false;
          updateDebugOutput();
        });
      }
      function applyAll() {
        normalizeConfig();
        updateRefCubes();
        ASSET_KEYS.forEach((key) => {
          applyAssetTransform(key);
          updateArrow(key);
        });
        updateFaceMarkers();
        if (simulationBuilt) {
          buildSimulation();
        }
        updateSimulationTransforms();
        saveConfig();
      }
      function setupAssetCard(key) {
        const uiCard = assetUI[key];
        if (!uiCard) return;
        if (uiCard.base) {
          uiCard.base.value = config.base[key] || uiCard.base.value;
          uiCard.base.addEventListener('change', () => {
            config.base[key] = uiCard.base.value;
            updateArrow(key);
            updateFaceMarkers();
            updateSimulationTransforms();
            saveConfig();
          });
        }
        const onInput = () => {
          const adj = config.adjust[key];
          adj.pos.x = parseNumber(uiCard.posX, 0);
          adj.pos.y = parseNumber(uiCard.posY, 0);
          adj.pos.z = parseNumber(uiCard.posZ, 0);
          adj.rotY = parseNumber(uiCard.rotY, 0);
          adj.scale = parseNumber(uiCard.scale, 1, 0.1, 50);
          applyAssetTransform(key);
          updateArrow(key);
          updateSimulationTransforms();
          saveConfig();
        };
        [uiCard.posX, uiCard.posY, uiCard.posZ, uiCard.rotY, uiCard.scale].forEach((el) => {
          if (!el) return;
          el.addEventListener('input', onInput);
        });
        if (uiCard.lockMove) {
          uiCard.lockMove.addEventListener('change', () => {
            config.adjust[key].lockMove = uiCard.lockMove.checked;
            saveConfig();
          });
        }
        syncAssetInputs(key);
      }
      applyGlobalToUI();
      ASSET_KEYS.forEach((key) => setupAssetCard(key));
      applyAll();
      [ui.cellSize, ui.assetSize, ui.wallScale, ui.assetOrigin, ui.refCubeSize, ui.refCubeScale].forEach((el) => {
        el.addEventListener('input', applyAll);
      });
      ui.refCubeWire.addEventListener('change', applyAll);
      ui.simEnabled.addEventListener('change', () => {
        if (!simulationEl) return;
        simulationEl.setAttribute('visible', ui.simEnabled.checked ? 'true' : 'false');
      });
      ui.simGenerate.addEventListener('click', () => {
        buildSimulation();
        updateSimulationTransforms();
        if (simulationEl) simulationEl.setAttribute('visible', 'true');
        ui.simEnabled.checked = true;
      });
      ui.debugEnabled.addEventListener('change', () => {
        updateDebugOutput();
      });
      ui.debugUpdate.addEventListener('click', () => {
        if (!ui.debugEnabled.checked) ui.debugEnabled.checked = true;
        updateDebugOutput();
      });
      ui.saveConfig.addEventListener('click', () => {
        applyAll();
      });
      ui.resetConfig.addEventListener('click', () => {
        const fresh = defaultConfig();
        Object.assign(config, fresh);
        applyGlobalToUI();
        ASSET_KEYS.forEach((key) => {
          config.base[key] = fresh.base[key];
          config.adjust[key] = JSON.parse(JSON.stringify(fresh.adjust[key]));
          const uiCard = assetUI[key];
          if (uiCard?.base) uiCard.base.value = config.base[key];
          syncAssetInputs(key);
        });
        applyAll();
      });
      const mouse = new THREE.Vector2();
      const dragState = {
        active: false,        key: null,        startMouse: {
          x: 0, y: 0
        },        startRotY: 0,        startScale: 1,        startLocalY: 0,        offset: new THREE.Vector3(),
      };
      function updateMouseNdc(e) {
        const canvas = document.querySelector('a-scene').canvas;
        if (!canvas) return;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      }
      function raycastToPlane(planeY = 0) {
        const scene = document.querySelector('a-scene');
        if (!scene || !scene.camera) return null;
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, scene.camera);
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
        const point = new THREE.Vector3();
        const hit = raycaster.ray.intersectPlane(plane, point);
        return hit ? point : null;
      }
      if (window.AFRAME && !AFRAME.components['drag-control']) {
        AFRAME.registerComponent('drag-control', {
          init() {
            this.onDown = () => {
              const key = this.el.dataset.key;
              if (!key) return;
              if (ui.dragMode.value === 'move' && config.adjust[key]?.lockMove) return;
              dragState.active = true;
              dragState.key = key;
              dragState.startMouse.x = mouse.x;
              dragState.startMouse.y = mouse.y;
              dragState.startRotY = config.adjust[key].rotY;
              dragState.startScale = config.adjust[key].scale;
              dragState.startLocalY = assets[key].object3D.position.y;
              const worldPos = new THREE.Vector3();
              assets[key].object3D.getWorldPosition(worldPos);
              const p = raycastToPlane(0);
              if (p) dragState.offset.copy(worldPos).sub(p);
            };
            this.el.addEventListener('mousedown', this.onDown);
          },          remove() {
            this.el.removeEventListener('mousedown', this.onDown);
          },
        });
      }
      Object.values(assets).forEach((el) => {
        el.setAttribute('drag-control', '');
      });
      window.addEventListener('mousemove', (e) => {
        updateMouseNdc(e);
        if (!dragState.active || !dragState.key) return;
        const key = dragState.key;
        const mode = ui.dragMode.value;
        if (mode === 'move') {
          const p = raycastToPlane(0);
          if (!p) return;
          const slot = slots[key];
          const local = slot.object3D.worldToLocal(p.clone().add(dragState.offset));
          local.y = dragState.startLocalY;
          assets[key].object3D.position.copy(local);
          config.adjust[key].pos.x = local.x;
          config.adjust[key].pos.z = local.z;
          config.adjust[key].pos.y = local.y - baseY();
        }
        else if (mode === 'rotate') {
          const dx = mouse.x - dragState.startMouse.x;
          config.adjust[key].rotY = dragState.startRotY + dx * 180;
        }
        else if (mode === 'scale') {
          const dy = mouse.y - dragState.startMouse.y;
          config.adjust[key].scale = Math.max(0.1, dragState.startScale * (1 - dy * 2));
        }
        applyAssetTransform(key);
        syncAssetInputs(key);
        updateArrow(key);
        updateSimulationTransforms();
        saveConfig();
      });
      window.addEventListener('mouseup', () => {
        dragState.active = false;
        dragState.key = null;
      });
      window.addEventListener('mousedown', updateMouseNdc);
      if (simulationEl) {
        simulationEl.setAttribute('visible', ui.simEnabled.checked ? 'true' : 'false');
      }
    </script>
  </body>
</html>
