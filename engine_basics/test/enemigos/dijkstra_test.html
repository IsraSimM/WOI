<!-- Prueba del algoritmo Dijkstra para navegaci√≥n de enemigos -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Test Dijkstra - Pathfinding</title>
    
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    
    <style>
      :root {
        --bg: #0b0d12;
        --panel: rgba(16, 21, 29, 0.95);
        --text: #e7e3d9;
        --muted: #9aa3ad;
        --accent: #f7b32b;
      }
      
      * {
        box-sizing: border-box;
      }
      
      body {
        margin: 0;
        font-family: "Segoe UI", system-ui, sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      
      .ui {
        position: fixed;
        top: 16px;
        left: 16px;
        width: 340px;
        max-height: calc(100vh - 32px);
        overflow-y: auto;
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 16px;
        backdrop-filter: blur(10px);
        z-index: 100;
      }
      
      .ui h1 {
        font-size: 18px;
        margin: 0 0 16px 0;
        color: var(--accent);
      }
      
      .section {
        margin-bottom: 16px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }
      
      .section h2 {
        font-size: 12px;
        text-transform: uppercase;
        color: var(--muted);
        letter-spacing: 0.5px;
        margin: 0 0 12px 0;
      }
      
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }
      
      input, select, button {
        width: 100%;
        padding: 8px;
        margin-bottom: 8px;
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        color: var(--text);
        font-size: 13px;
      }
      
      input[type="number"] {
        width: 100%;
      }
      
      input[type="checkbox"] {
        width: auto;
        margin-right: 8px;
      }
      
      button {
        cursor: pointer;
        background: linear-gradient(135deg, rgba(247, 179, 43, 0.25), rgba(45, 212, 191, 0.2));
        border: 1px solid var(--accent);
        font-weight: 600;
        transition: all 0.2s;
      }
      
      button:hover {
        background: linear-gradient(135deg, rgba(247, 179, 43, 0.35), rgba(45, 212, 191, 0.3));
        transform: translateY(-1px);
      }
      
      button.secondary {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.15);
      }
      
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      
      .info {
        padding: 8px;
        background: rgba(45, 212, 191, 0.1);
        border: 1px solid rgba(45, 212, 191, 0.3);
        border-radius: 6px;
        font-size: 11px;
        color: #2dd4bf;
        margin-bottom: 8px;
      }
      
      .warning {
        padding: 8px;
        background: rgba(249, 115, 22, 0.1);
        border: 1px solid rgba(249, 115, 22, 0.3);
        border-radius: 6px;
        font-size: 11px;
        color: #f97316;
        margin-bottom: 8px;
      }
      
      .canvas-container {
        margin: 12px 0;
      }
      
      canvas {
        width: 100%;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        background: #1a1f2b;
        image-rendering: pixelated;
      }
      
      .status {
        font-size: 11px;
        color: var(--muted);
        margin-top: 8px;
        padding: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
      }
    </style>
  </head>
  
  <body>
    <!-- Panel de control -->
    <div class="ui">
      <h1>üéØ Test Dijkstra Pathfinding</h1>
      
      <!-- Generaci√≥n del mapa -->
      <div class="section">
        <h2>Generar Mapa</h2>
        
        <div class="row">
          <div>
            <label>Ancho</label>
            <input type="number" id="width" value="15" min="5" max="30">
          </div>
          <div>
            <label>Alto</label>
            <input type="number" id="height" value="15" min="5" max="30">
          </div>
        </div>
        
        <label>Densidad de paredes (0-100%)</label>
        <input type="number" id="wallDensity" value="25" min="0" max="80" step="5">
        
        <button id="generateMap">üîÑ Generar Mapa Aleatorio</button>
        <button id="clearMap" class="secondary">‚¨ú Limpiar Todo</button>
      </div>
      
      <!-- Puntos de inicio y fin -->
      <div class="section">
        <h2>Configurar Pathfinding</h2>
        
        <div class="info">
          üí° Haz clic en el mapa para colocar los puntos
        </div>
        
        <div>
          <label>
            <input type="checkbox" id="setStartMode" checked>
            Modo: Colocar inicio (verde)
          </label>
        </div>
        
        <div>
          <label>
            <input type="checkbox" id="setEndMode">
            Modo: Colocar fin (rojo)
          </label>
        </div>
        
        <div class="row">
          <div>
            <label>Inicio X</label>
            <input type="number" id="startX" value="1" min="0">
          </div>
          <div>
            <label>Inicio Y</label>
            <input type="number" id="startY" value="1" min="0">
          </div>
        </div>
        
        <div class="row">
          <div>
            <label>Fin X</label>
            <input type="number" id="endX" value="13" min="0">
          </div>
          <div>
            <label>Fin Y</label>
            <input type="number" id="endY" value="13" min="0">
          </div>
        </div>
        
        <button id="applyPoints" class="secondary">‚úì Aplicar Coordenadas</button>
      </div>
      
      <!-- Visualizaci√≥n del mapa -->
      <div class="section">
        <h2>Mapa 2D</h2>
        <div class="canvas-container">
          <canvas id="mapCanvas" width="300" height="300"></canvas>
        </div>
        <div class="status" id="mapStatus">
          Dimensiones: 15 x 15 | Paredes: 0
        </div>
      </div>
      
      <!-- Ejecutar Dijkstra -->
      <div class="section">
        <h2>Ejecutar Algoritmo</h2>
        
        <button id="runDijkstra">üöÄ Calcular Camino (Dijkstra)</button>
        <button id="clearPath" class="secondary">üóëÔ∏è Limpiar Camino</button>
        
        <div>
          <label>
            <input type="checkbox" id="showPath" checked>
            Mostrar camino en 3D
          </label>
        </div>
        
        <div>
          <label>
            <input type="checkbox" id="animatePath" checked>
            Animar Pacman en el camino (velocidad del jugador)
          </label>
        </div>
        
        <label>Duraci√≥n de pausa al llegar (ms)</label>
        <input type="number" id="pauseDuration" value="2000" min="500" max="5000" step="500">
        
        <div class="status" id="pathStatus">
          Esperando c√°lculo...
        </div>
      </div>
      
      <!-- Opciones de visualizaci√≥n 3D -->
      <div class="section">
        <h2>Visualizaci√≥n 3D</h2>
        
        <label>Tama√±o de celda</label>
        <input type="number" id="cellSize" value="2" min="1" max="5" step="0.5">
        
        <label>Altura de paredes</label>
        <input type="number" id="wallHeight" value="3" min="1" max="10" step="0.5">
        
        <button id="rebuild3D" class="secondary">üî® Reconstruir 3D</button>
      </div>
      
      <!-- Sistema de Audio -->
      <div class="section">
        <h2>Sistema de Audio üîä</h2>
        
        <div>
          <label>
            <input type="checkbox" id="audioEnabled" checked>
            Habilitar sistema de audio
          </label>
        </div>
        
        <div class="info">
          üéµ El audio se activa durante la animaci√≥n del camino
        </div>
        
        <label>Distancia de campo de visi√≥n</label>
        <input type="number" id="viewDistance" value="15" min="5" max="30" step="1">
        
        <label>Distancia "cerca" (approaching)</label>
        <input type="number" id="closeDistance" value="8" min="3" max="20" step="1">
        
        <div class="status" id="audioStatus">
          Sistema de audio: Esperando animaci√≥n...
        </div>
        
        <div class="info" id="audioIndicator" style="display: none;">
          üîä <span id="audioText">Reproduciendo...</span>
        </div>
      </div>
    </div>
    
    <!-- Escena A-Frame -->
    <a-scene background="color: #9aa0a6" renderer="antialias: true; colorManagement: true;">
      
      <!-- Assets -->
      <a-assets>
        <a-asset-item id="mdl-full" src="../../assets/blocks/full.glb"></a-asset-item>
        <a-asset-item id="pacmanModel" src="assets/Pacman.glb"></a-asset-item>
        
        <!-- Audio Assets -->
        <audio id="snd-approaching1" src="assets/approaching_monster.wav" preload="auto"></audio>
        <audio id="snd-approaching2" src="assets/approaching_monster2.wav" preload="auto"></audio>
        <audio id="snd-monster-view" src="assets/monster_view.wav" preload="auto"></audio>
        <audio id="snd-monster-eat" src="assets/monster_eat.wav" preload="auto"></audio>
      </a-assets>
      
      <!-- Rig de c√°mara -->
      <a-entity id="rig" position="15 20 20">
        <a-entity camera 
                  look-controls="reverseMouseDrag: true" 
                  wasd-controls="acceleration: 60; fly: true">
        </a-entity>
      </a-entity>
      
      <!-- Iluminaci√≥n -->
      <a-entity light="type: ambient; intensity: 0.6"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="10 20 10"></a-entity>
      
      <!-- Piso base -->
      <a-plane id="floor" 
               rotation="-90 0 0" 
               width="100" 
               height="100" 
               color="#cfd2d6"
               position="0 -0.1 0">
      </a-plane>
      
      <!-- Contenedor del mapa 3D -->
      <a-entity id="map3d"></a-entity>
      
      <!-- Marcadores de inicio y fin -->
      <a-entity id="markers"></a-entity>
      
      <!-- Camino visualizado -->
      <a-entity id="path3d"></a-entity>
      
      <!-- Entidad que se mueve por el camino (Pacman) -->
      <a-entity id="pathEntity" 
                visible="false"
                position="0 0.5 0">
        <a-entity gltf-model="#pacmanModel" 
                  scale="0.2 0.2 0.2" 
                  rotation="0 0 0">
        </a-entity>
        
        <!-- Sistema de Audio del Enemigo -->
        <a-sound id="sound-approaching1" src="#snd-approaching1" volume="0.8"></a-sound>
        <a-sound id="sound-approaching2" src="#snd-approaching2" volume="0.8"></a-sound>
        <a-sound id="sound-monster-view" src="#snd-monster-view" volume="1.0"></a-sound>
        <a-sound id="sound-monster-eat" src="#snd-monster-eat" volume="1.0"></a-sound>
      </a-entity>
      
    </a-scene>
    
    <script type="module">
      import { dijkstraPath } from './scripts/ai/dijkstra.js';
      import { EnemyAudioSystem } from './scripts/systems/AudioSystem.js';
      
      // Referencias al DOM
      const $ = (id) => document.getElementById(id);
      const ui = {
        width: $('width'),
        height: $('height'),
        wallDensity: $('wallDensity'),
        generateMap: $('generateMap'),
        clearMap: $('clearMap'),
        setStartMode: $('setStartMode'),
        setEndMode: $('setEndMode'),
        startX: $('startX'),
        startY: $('startY'),
        endX: $('endX'),
        endY: $('endY'),
        applyPoints: $('applyPoints'),
        mapCanvas: $('mapCanvas'),
        mapStatus: $('mapStatus'),
        runDijkstra: $('runDijkstra'),
        clearPath: $('clearPath'),
        showPath: $('showPath'),
        animatePath: $('animatePath'),
        pathStatus: $('pathStatus'),
        pauseDuration: $('pauseDuration'),
        cellSize: $('cellSize'),
        wallHeight: $('wallHeight'),
        rebuild3D: $('rebuild3D'),
        audioEnabled: $('audioEnabled'),
        viewDistance: $('viewDistance'),
        closeDistance: $('closeDistance'),
        audioStatus: $('audioStatus'),
        audioIndicator: $('audioIndicator'),
        audioText: $('audioText'),
      };
      
      const map3dEl = $('map3d');
      const markersEl = $('markers');
      const path3dEl = $('path3d');
      const pathEntityEl = $('pathEntity');
      
      // Sistema de Audio
      const audioSystem = new EnemyAudioSystem();
      
      // Estado del sistema
      const state = {
        width: 15,
        height: 15,
        map: null, // Uint8Array
        start: { x: 1, y: 1 },
        end: { x: 13, y: 13 },
        path: [],
        cellSize: 2,
        wallHeight: 3,
        animating: false,
        animationId: null,
        playerSpeed: 8, // Velocidad del jugador en unidades/segundo (igual que enemies.html)
        cameraPosition: { x: 0, y: 0, z: 0 }, // Posici√≥n de la c√°mara (representa al jugador)
        isPaused: false, // Estado de pausa cuando llega al destino
        pauseStartTime: 0, // Tiempo de inicio de la pausa
        pauseDuration: 4000, // Duraci√≥n de la pausa en ms (para reproducir audio)
      };
      
      // Constantes
      const CELL = {
        EMPTY: 0,
        WALL: 1,
      };
      
      const COLORS = {
        empty: '#e5e7eb',
        wall: '#374151',
        start: '#22c55e',
        end: '#ef4444',
        path: '#3b82f6',
      };
      
      // ==================== GENERACI√ìN DEL MAPA ====================
      
      function createEmptyMap(width, height) {
        return new Uint8Array(width * height);
      }
      
      function generateRandomMap(width, height, wallDensity) {
        const map = createEmptyMap(width, height);
        const density = Math.max(0, Math.min(1, wallDensity / 100));
        
        for (let i = 0; i < map.length; i++) {
          if (Math.random() < density) {
            map[i] = CELL.WALL;
          }
        }
        
        // Asegurar que inicio y fin no sean paredes
        const startIdx = state.start.y * width + state.start.x;
        const endIdx = state.end.y * width + state.end.x;
        map[startIdx] = CELL.EMPTY;
        map[endIdx] = CELL.EMPTY;
        
        return map;
      }
      
      function clearMap() {
        state.map = createEmptyMap(state.width, state.height);
        state.path = [];
        renderMap2D();
        updateMapStatus();
        clearPath3D();
      }
      
      function countWalls() {
        if (!state.map) return 0;
        let count = 0;
        for (let i = 0; i < state.map.length; i++) {
          if (state.map[i] === CELL.WALL) count++;
        }
        return count;
      }
      
      function updateMapStatus() {
        const walls = countWalls();
        ui.mapStatus.textContent = `Dimensiones: ${state.width} x ${state.height} | Paredes: ${walls}`;
      }
      
      // ==================== RENDERIZADO 2D ====================
      
      function renderMap2D() {
        const canvas = ui.mapCanvas;
        const ctx = canvas.getContext('2d');
        const w = state.width;
        const h = state.height;
        const cellW = canvas.width / w;
        const cellH = canvas.height / h;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Dibujar celdas
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = y * w + x;
            const cell = state.map[idx];
            
            // Color base
            ctx.fillStyle = cell === CELL.WALL ? COLORS.wall : COLORS.empty;
            ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
            
            // Borde de celda
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * cellW, y * cellH, cellW, cellH);
          }
        }
        
        // Dibujar camino
        if (state.path.length > 0) {
          ctx.fillStyle = COLORS.path;
          for (const point of state.path) {
            ctx.fillRect(
              point.x * cellW + cellW * 0.2,
              point.y * cellH + cellH * 0.2,
              cellW * 0.6,
              cellH * 0.6
            );
          }
        }
        
        // Dibujar marcador de inicio
        ctx.fillStyle = COLORS.start;
        ctx.beginPath();
        ctx.arc(
          state.start.x * cellW + cellW / 2,
          state.start.y * cellH + cellH / 2,
          Math.min(cellW, cellH) * 0.3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        // Dibujar marcador de fin
        ctx.fillStyle = COLORS.end;
        ctx.beginPath();
        ctx.arc(
          state.end.x * cellW + cellW / 2,
          state.end.y * cellH + cellH / 2,
          Math.min(cellW, cellH) * 0.3,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }
      
      // ==================== RENDERIZADO 3D ====================
      
      function clearEntity(parent) {
        while (parent.firstChild) {
          parent.removeChild(parent.firstChild);
        }
      }
      
      function build3DMap() {
        clearEntity(map3dEl);
        
        const w = state.width;
        const h = state.height;
        const cellSize = state.cellSize;
        const wallHeight = state.wallHeight;
        
        // Calcular offset para centrar el mapa
        const offsetX = -(w * cellSize) / 2;
        const offsetZ = -(h * cellSize) / 2;
        
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = y * w + x;
            if (state.map[idx] === CELL.WALL) {
              const wall = document.createElement('a-box');
              wall.setAttribute('width', cellSize);
              wall.setAttribute('height', wallHeight);
              wall.setAttribute('depth', cellSize);
              wall.setAttribute('color', '#6b7280');
              wall.setAttribute('position', {
                x: offsetX + x * cellSize + cellSize / 2,
                y: wallHeight / 2,
                z: offsetZ + y * cellSize + cellSize / 2,
              });
              map3dEl.appendChild(wall);
            }
          }
        }
        
        // Actualizar posici√≥n del piso
        const floorSize = Math.max(w, h) * cellSize + 10;
        $('floor').setAttribute('width', floorSize);
        $('floor').setAttribute('height', floorSize);
      }
      
      function renderMarkers3D() {
        clearEntity(markersEl);
        
        const cellSize = state.cellSize;
        const w = state.width;
        const h = state.height;
        const offsetX = -(w * cellSize) / 2;
        const offsetZ = -(h * cellSize) / 2;
        
        // Marcador de inicio
        const startMarker = document.createElement('a-cylinder');
        startMarker.setAttribute('radius', cellSize * 0.3);
        startMarker.setAttribute('height', 0.3);
        startMarker.setAttribute('color', COLORS.start);
        startMarker.setAttribute('position', {
          x: offsetX + state.start.x * cellSize + cellSize / 2,
          y: 0.2,
          z: offsetZ + state.start.y * cellSize + cellSize / 2,
        });
        markersEl.appendChild(startMarker);
        
        // Marcador de fin
        const endMarker = document.createElement('a-cylinder');
        endMarker.setAttribute('radius', cellSize * 0.3);
        endMarker.setAttribute('height', 0.3);
        endMarker.setAttribute('color', COLORS.end);
        endMarker.setAttribute('position', {
          x: offsetX + state.end.x * cellSize + cellSize / 2,
          y: 0.2,
          z: offsetZ + state.end.y * cellSize + cellSize / 2,
        });
        markersEl.appendChild(endMarker);
      }
      
      function renderPath3D() {
        clearEntity(path3dEl);
        
        if (!ui.showPath.checked || state.path.length === 0) return;
        
        const cellSize = state.cellSize;
        const w = state.width;
        const h = state.height;
        const offsetX = -(w * cellSize) / 2;
        const offsetZ = -(h * cellSize) / 2;
        
        for (const point of state.path) {
          const pathNode = document.createElement('a-box');
          pathNode.setAttribute('width', cellSize * 0.4);
          pathNode.setAttribute('height', 0.2);
          pathNode.setAttribute('depth', cellSize * 0.4);
          pathNode.setAttribute('color', COLORS.path);
          pathNode.setAttribute('position', {
            x: offsetX + point.x * cellSize + cellSize / 2,
            y: 0.15,
            z: offsetZ + point.y * cellSize + cellSize / 2,
          });
          path3dEl.appendChild(pathNode);
        }
      }
      
      function clearPath3D() {
        clearEntity(path3dEl);
        stopAnimation();
      }
      
      function rebuild3D() {
        state.cellSize = parseFloat(ui.cellSize.value);
        state.wallHeight = parseFloat(ui.wallHeight.value);
        build3DMap();
        renderMarkers3D();
        renderPath3D();
      }
      
      // ==================== ALGORITMO DIJKSTRA ====================
      
      function runDijkstraAlgorithm() {
        if (!state.map) {
          ui.pathStatus.textContent = '‚ùå No hay mapa generado';
          return;
        }
        
        // Validar coordenadas
        const startX = Math.max(0, Math.min(state.width - 1, state.start.x));
        const startY = Math.max(0, Math.min(state.height - 1, state.start.y));
        const endX = Math.max(0, Math.min(state.width - 1, state.end.x));
        const endY = Math.max(0, Math.min(state.height - 1, state.end.y));
        
        const start = { x: startX, y: startY };
        const end = { x: endX, y: endY };
        
        // Ejecutar Dijkstra
        console.time('Dijkstra');
        state.path = dijkstraPath(state.map, state.width, state.height, start, end);
        console.timeEnd('Dijkstra');
        
        // Mostrar resultados
        if (state.path.length === 0) {
          ui.pathStatus.textContent = '‚ùå No se encontr√≥ camino';
          ui.pathStatus.style.background = 'rgba(249, 115, 22, 0.2)';
        } else {
          ui.pathStatus.textContent = `‚úÖ Camino encontrado: ${state.path.length} pasos`;
          ui.pathStatus.style.background = 'rgba(34, 197, 94, 0.2)';
        }
        
        renderMap2D();
        renderPath3D();
        
        if (ui.animatePath.checked && state.path.length > 0) {
          startPathAnimation();
        }
      }
      
      // ==================== ANIMACI√ìN ====================
      
      function stopAnimation() {
        state.animating = false;
        state.isPaused = false;
        if (state.animationId !== null) {
          cancelAnimationFrame(state.animationId);
          state.animationId = null;
        }
        pathEntityEl.setAttribute('visible', false);
        audioSystem.reset(); // Resetear estado de audio
        updateAudioStatus();
      }
      
      function startPathAnimation() {
        stopAnimation();
        
        if (state.path.length === 0) return;
        
        state.animating = true;
        pathEntityEl.setAttribute('visible', true);
        
        // Actualizar estado de audio
        updateAudioStatus();
        
        // Actualizar duraci√≥n de pausa desde UI
        state.pauseDuration = parseInt(ui.pauseDuration.value);
        
        let step = 0;
        const cellSize = state.cellSize;
        const timePerStep = cellSize / state.playerSpeed; // Tiempo para moverse una celda
        let lastTime = performance.now();
        
        const w = state.width;
        const h = state.height;
        const offsetX = -(w * cellSize) / 2;
        const offsetZ = -(h * cellSize) / 2;
        
        // Funci√≥n para calcular la rotaci√≥n hacia un punto
        function getRotationTowards(from, to) {
          const dx = to.x - from.x;
          const dz = to.z - from.z;
          const angle = Math.atan2(dx, dz) * (180 / Math.PI);
          return angle + 270; // Ajuste para la orientaci√≥n del modelo Pacman
        }
        
        function animate(currentTime) {
          if (!state.animating) return;
          
          // Verificar si est√° en pausa
          if (state.isPaused) {
            const pauseElapsed = currentTime - state.pauseStartTime;
            if (pauseElapsed >= state.pauseDuration) {
              // Terminar pausa y reiniciar el loop
              state.isPaused = false;
              step = 0;
              lastTime = currentTime;
            }
            state.animationId = requestAnimationFrame(animate);
            return;
          }
          
          const delta = (currentTime - lastTime) / 1000;
          
          if (delta >= timePerStep) {
            const point = state.path[step];
            
            const newPos = {
              x: offsetX + point.x * cellSize + cellSize / 2,
              y: 0.5,
              z: offsetZ + point.y * cellSize + cellSize / 2,
            };
            
            // Si hay un siguiente punto, rotar hacia √©l
            if (step < state.path.length - 1) {
              const nextPoint = state.path[step + 1];
              const nextPos = {
                x: offsetX + nextPoint.x * cellSize + cellSize / 2,
                z: offsetZ + nextPoint.y * cellSize + cellSize / 2,
              };
              
              const rotation = getRotationTowards(
                { x: newPos.x, z: newPos.z },
                { x: nextPos.x, z: nextPos.z }
              );
              
              pathEntityEl.setAttribute('rotation', {
                x: 0,
                y: rotation,
                z: 0,
              });
            }
            
            pathEntityEl.setAttribute('position', newPos);
            
            step++;
            lastTime = currentTime;
            
            // Verificar si lleg√≥ al final del camino
            if (step >= state.path.length) {
              // Reproducir sonido de "comer"
              if (ui.audioEnabled.checked) {
                audioSystem.playEatSound();
                console.log('üéØ Enemigo alcanz√≥ el destino! Reproduciendo "monster eat"');
              }
              // Iniciar pausa
              state.isPaused = true;
              state.pauseStartTime = currentTime;
              console.log(`‚è∏Ô∏è Pausa iniciada (${state.pauseDuration}ms)`);
            }
          }
          
          // Actualizar posici√≥n de la c√°mara (jugador)
          updateCameraPosition();
          
          // Actualizar sistema de audio (solo si no est√° en pausa)
          if (ui.audioEnabled.checked && !state.isPaused) {
            const enemyPos = pathEntityEl.getAttribute('position');
            audioSystem.update(enemyPos, state.cameraPosition);
          }
          
          state.animationId = requestAnimationFrame(animate);
        }
        
        state.animationId = requestAnimationFrame(animate);
      }
      
      // ==================== SISTEMA DE AUDIO ====================
      
      function initializeAudioSystem() {
        // Obtener referencias a los elementos de sonido
        const soundElements = {
          approaching1: $('sound-approaching1'),
          approaching2: $('sound-approaching2'),
          monsterView: $('sound-monster-view'),
          monsterEat: $('sound-monster-eat'),
        };
        
        audioSystem.initialize(soundElements);
        
        // Configurar distancias
        audioSystem.configure({
          viewDistance: parseFloat(ui.viewDistance.value),
          closeDistance: parseFloat(ui.closeDistance.value),
        });
        
        // Configurar callback para mostrar indicador visual
        audioSystem.onSoundPlay = (soundKey) => {
          showAudioIndicator(soundKey);
        };
      }
      
      function showAudioIndicator(soundKey) {
        const soundNames = {
          approaching1: 'Approaching (1)',
          approaching2: 'Approaching (2)',
          monsterView: 'Monster View!',
          monsterEat: 'üíÄ Monster Eat!',
        };
        
        ui.audioIndicator.style.display = 'block';
        ui.audioText.textContent = soundNames[soundKey] || soundKey;
        
        // Ocultar despu√©s de 1.5 segundos
        setTimeout(() => {
          ui.audioIndicator.style.display = 'none';
        }, 1500);
      }
      
      function updateCameraPosition() {
        const cameraEl = document.querySelector('[camera]');
        if (cameraEl) {
          const pos = cameraEl.getAttribute('position');
          state.cameraPosition = { x: pos.x, y: pos.y, z: pos.z };
        }
      }
      
      function updateAudioStatus() {
        if (ui.audioEnabled.checked && state.animating) {
          ui.audioStatus.textContent = 'üîä Sistema de audio activo';
          ui.audioStatus.style.background = 'rgba(34, 197, 94, 0.2)';
        } else {
          ui.audioStatus.textContent = 'Sistema de audio: Esperando animaci√≥n...';
          ui.audioStatus.style.background = '';
        }
      }
      
      // ==================== INTERACCI√ìN CON EL CANVAS ====================
      
      ui.mapCanvas.addEventListener('click', (e) => {
        const rect = ui.mapCanvas.getBoundingClientRect();
        const x = Math.floor(((e.clientX - rect.left) / rect.width) * state.width);
        const y = Math.floor(((e.clientY - rect.top) / rect.height) * state.height);
        
        if (x < 0 || y < 0 || x >= state.width || y >= state.height) return;
        
        if (ui.setStartMode.checked) {
          state.start = { x, y };
          ui.startX.value = x;
          ui.startY.value = y;
          
          // Asegurar que no sea pared
          const idx = y * state.width + x;
          state.map[idx] = CELL.EMPTY;
          
          renderMap2D();
          renderMarkers3D();
        } else if (ui.setEndMode.checked) {
          state.end = { x, y };
          ui.endX.value = x;
          ui.endY.value = y;
          
          // Asegurar que no sea pared
          const idx = y * state.width + x;
          state.map[idx] = CELL.EMPTY;
          
          renderMap2D();
          renderMarkers3D();
        }
      });
      
      // ==================== EVENT LISTENERS ====================
      
      ui.generateMap.addEventListener('click', () => {
        state.width = parseInt(ui.width.value);
        state.height = parseInt(ui.height.value);
        const density = parseInt(ui.wallDensity.value);
        
        state.map = generateRandomMap(state.width, state.height, density);
        state.path = [];
        
        // Ajustar inicio y fin si est√°n fuera de rango
        state.start.x = Math.min(state.start.x, state.width - 1);
        state.start.y = Math.min(state.start.y, state.height - 1);
        state.end.x = Math.min(state.end.x, state.width - 1);
        state.end.y = Math.min(state.end.y, state.height - 1);
        
        ui.startX.setAttribute('max', state.width - 1);
        ui.startY.setAttribute('max', state.height - 1);
        ui.endX.setAttribute('max', state.width - 1);
        ui.endY.setAttribute('max', state.height - 1);
        
        updateMapStatus();
        renderMap2D();
        rebuild3D();
      });
      
      ui.clearMap.addEventListener('click', clearMap);
      
      ui.applyPoints.addEventListener('click', () => {
        state.start.x = Math.max(0, Math.min(state.width - 1, parseInt(ui.startX.value)));
        state.start.y = Math.max(0, Math.min(state.height - 1, parseInt(ui.startY.value)));
        state.end.x = Math.max(0, Math.min(state.width - 1, parseInt(ui.endX.value)));
        state.end.y = Math.max(0, Math.min(state.height - 1, parseInt(ui.endY.value)));
        
        // Asegurar que no sean paredes
        const startIdx = state.start.y * state.width + state.start.x;
        const endIdx = state.end.y * state.width + state.end.x;
        state.map[startIdx] = CELL.EMPTY;
        state.map[endIdx] = CELL.EMPTY;
        
        renderMap2D();
        renderMarkers3D();
      });
      
      ui.runDijkstra.addEventListener('click', runDijkstraAlgorithm);
      
      ui.clearPath.addEventListener('click', () => {
        state.path = [];
        ui.pathStatus.textContent = 'Esperando c√°lculo...';
        ui.pathStatus.style.background = '';
        renderMap2D();
        clearPath3D();
      });
      
      ui.showPath.addEventListener('change', () => {
        renderPath3D();
      });
      
      ui.animatePath.addEventListener('change', () => {
        if (ui.animatePath.checked && state.path.length > 0) {
          startPathAnimation();
        } else {
          stopAnimation();
        }
      });
      
      ui.pauseDuration.addEventListener('change', () => {
        state.pauseDuration = parseInt(ui.pauseDuration.value);
        console.log(`‚è±Ô∏è Duraci√≥n de pausa actualizada: ${state.pauseDuration}ms`);
      });
      
      ui.rebuild3D.addEventListener('click', rebuild3D);
      
      ui.audioEnabled.addEventListener('change', () => {
        audioSystem.setEnabled(ui.audioEnabled.checked);
        updateAudioStatus();
      });
      
      ui.viewDistance.addEventListener('change', () => {
        audioSystem.configure({
          viewDistance: parseFloat(ui.viewDistance.value),
        });
      });
      
      ui.closeDistance.addEventListener('change', () => {
        audioSystem.configure({
          closeDistance: parseFloat(ui.closeDistance.value),
        });
      });
      
      ui.setStartMode.addEventListener('change', () => {
        if (ui.setStartMode.checked) {
          ui.setEndMode.checked = false;
        }
      });
      
      ui.setEndMode.addEventListener('change', () => {
        if (ui.setEndMode.checked) {
          ui.setStartMode.checked = false;
        }
      });
      
      // ==================== INICIALIZACI√ìN ====================
      
      function init() {
        state.map = generateRandomMap(state.width, state.height, 25);
        updateMapStatus();
        renderMap2D();
        rebuild3D();
        
        console.log('‚úÖ Sistema de prueba Dijkstra inicializado');
        console.log('üìä Mapa:', state);
      }
      
      // Esperar a que A-Frame est√© listo
      document.querySelector('a-scene').addEventListener('loaded', () => {
        init();
        
        // Inicializar sistema de audio despu√©s de que la escena est√© lista
        setTimeout(() => {
          initializeAudioSystem();
          console.log('üîä Sistema de audio inicializado');
        }, 1000);
      });
    </script>
  </body>
</html>
