<!-- Prueba de simulacion de enemigos -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Room Test - Modular</title>
    
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    
    <!-- Scripts modulares en orden de dependencias -->
    <script defer src="scripts/core/configuracionDatos.js"></script>
    <script defer src="scripts/systems/Coliciones.js"></script>
    <script defer src="scripts/systems/ConstruccionSala.js"></script>
    <script defer src="scripts/systems/Items.js"></script>
    <script defer src="scripts/systems/Navegacion.js"></script>
    <script defer src="scripts/systems/Movimiento.js"></script>
    <script defer src="scripts/core/Inicializacion.js"></script>
    
    <style>
      :root {
        --bg-panel: rgba(16, 21, 29, 0.95);
        --text: #e7e3d9;
        --muted: #9aa3ad;
        --accent: #f7b32b;
        --border: rgba(255, 255, 255, 0.1);
      }
      
      * {
        box-sizing: border-box;
      }
      
      body {
        margin: 0;
        font-family: "Segoe UI", system-ui, sans-serif;
      }
      
      /* Panel de control de expresiones */
      .expression-panel {
        position: fixed;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        width: 220px;
        background: var(--bg-panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 16px;
        backdrop-filter: blur(10px);
        z-index: 100;
      }
      
      .expression-panel h2 {
        font-size: 14px;
        margin: 0 0 12px 0;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        text-align: center;
      }
      
      .expression-btn {
        width: 100%;
        padding: 12px;
        margin-bottom: 8px;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(139, 92, 246, 0.15));
        border: 1px solid rgba(59, 130, 246, 0.4);
        border-radius: 8px;
        color: var(--text);
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      
      .expression-btn:hover {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.35), rgba(139, 92, 246, 0.25));
        transform: translateX(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }
      
      .expression-btn.active {
        background: linear-gradient(135deg, rgba(247, 179, 43, 0.35), rgba(45, 212, 191, 0.25));
        border-color: var(--accent);
        box-shadow: 0 0 16px rgba(247, 179, 43, 0.4);
      }
      
      .expression-btn .emoji {
        font-size: 18px;
      }
      
      .divider {
        height: 1px;
        background: var(--border);
        margin: 12px 0;
      }
      
      .morph-control {
        margin-bottom: 12px;
      }
      
      .morph-control label {
        display: block;
        font-size: 11px;
        color: var(--muted);
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 0.3px;
      }
      
      .morph-slider {
        width: 100%;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.1);
        outline: none;
      }
      
      .morph-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .morph-slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 0 8px var(--accent);
      }
      
      .morph-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
        border: none;
      }
      
      .morph-value {
        display: inline-block;
        font-size: 10px;
        color: var(--accent);
        font-weight: 600;
        margin-left: 4px;
      }
      
      .status-indicator {
        font-size: 10px;
        color: var(--muted);
        text-align: center;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 6px;
        margin-top: 12px;
      }
      
      .status-indicator.ready {
        color: #22c55e;
      }
    </style>
  </head>
  
  <body>
    <a-scene background="color: #9aa0a6" renderer="antialias: true; colorManagement: true;">
      
      <!-- Assets -->
      <a-assets>
        <a-asset-item id="pacmanModel" src="assets/Pacman.glb"></a-asset-item>
        <a-asset-item id="mdl-full" src="../../assets/blocks/full.glb"></a-asset-item>
      </a-assets>

      <!-- Player con controles de movimiento -->
      <a-entity id="player" 
                position="0 0.1 0"
                room-player="speed: 8; jump: 6; gravity: 18; radius: 1.2; height: 1.6; sprintMult: 1.3">
        
        <!-- Head con step-bob -->
        <a-entity id="head" 
                  step-bob="enabled: true; intensity: 0.028; frequency: 3.4; sway: 0.45; maxSpeed: 8; airScale: 0.15; jumpLift: 0.035; landDip: 0.06; strafeTilt: 2.2; spring: 28; damping: 10; sprintFov: 4; sprintBob: 1.2">
          
          <!-- Camera -->
          <a-entity camera 
                    look-controls="mouseSensitivity: 0.08; touchSensitivity: 0.8" 
                    position="0 1.6 0">
          </a-entity>
        </a-entity>

        <!-- Body visual del jugador -->
        <a-entity id="body">
          <a-cylinder radius="0.35" height="1.2" color="#3b82f6" position="0 0.6 0"></a-cylinder>
          <a-sphere radius="0.28" color="#f97316" position="0 1.45 0"></a-sphere>
        </a-entity>
      </a-entity>

      <!-- Enemigo de prueba (ajustado para el mini escenario) -->
      <a-entity id="enemy" 
                gltf-model="#pacmanModel" 
                rotation="0 270 0" 
                position="0 0.5 -10" 
                scale="0.5 0.5 0.5">
      </a-entity>

      <!-- Sala (room se construye din√°micamente) -->
      <a-entity id="room"></a-entity>
      
      <!-- Piso -->
      <a-plane id="floor" 
               position="0 0 0" 
               rotation="-90 0 0" 
               width="100" 
               height="100" 
               color="#4b5563">
      </a-plane>

      <!-- Cielo -->
      <a-sky color="#9aa0a6"></a-sky>
      
    </a-scene>
    
    <!-- Panel de Control de Expresiones -->
    <div class="expression-panel">
      <h2>üé≠ Expresiones</h2>
      
      <button class="expression-btn active" data-expression="neutral">
        <span class="emoji">üòê</span>
        <span>Neutral</span>
      </button>
      
      <button class="expression-btn" data-expression="happy">
        <span class="emoji">üòä</span>
        <span>Feliz</span>
      </button>
      
      <button class="expression-btn" data-expression="angry">
        <span class="emoji">üò†</span>
        <span>Enojado</span>
      </button>
      
      <div class="divider"></div>
      
      <div id="morphControls">
        <!-- Los controles deslizantes se generar√°n din√°micamente -->
      </div>
      
      <button class="expression-btn" id="diagnosticBtn" style="background: rgba(249, 115, 22, 0.2); border-color: rgba(249, 115, 22, 0.5); margin-top: 8px;">
        <span class="emoji">üîç</span>
        <span>Diagn√≥stico</span>
      </button>
      
      <div class="status-indicator" id="morphStatus">
        Cargando...
      </div>
    </div>
    
    <!-- Script de control de Morph Targets -->
    <script type="module">
      import { MorphTargetController, morphTargetManager } from './scripts/systems/MorphTargetController.js';
      
      let enemyMorphController;
      
      // Esperar a que A-Frame est√© listo
      document.querySelector('a-scene').addEventListener('loaded', async () => {
        console.log('üé¨ Escena cargada, inicializando control de expresiones...');
        
        // Esperar un poco m√°s para asegurar que el modelo est√© completamente cargado
        setTimeout(async () => {
          await initializeMorphControl();
        }, 1500);
      });
      
      async function initializeMorphControl() {
        try {
          // Crear controlador para el enemigo
          enemyMorphController = new MorphTargetController('enemy');
          await enemyMorphController.initialize();
          
          // Registrar en el manager global
          morphTargetManager.register('enemy', enemyMorphController);
          
          // Configurar callback
          enemyMorphController.onExpressionChange = (expression) => {
            updateActiveButton(expression);
          };
          
          // Actualizar UI
          updateStatus('ready');
          createMorphSliders();
          
          // Sincronizar sliders con el estado inicial (neutral)
          setTimeout(() => {
            updateSlidersFromCurrentExpression('neutral');
          }, 100);
          
          console.log('‚úÖ Sistema de expresiones inicializado');
          console.log('üé≠ Morph targets disponibles:', enemyMorphController.getMorphTargets());
          
        } catch (error) {
          console.error('‚ùå Error al inicializar control de expresiones:', error);
          updateStatus('error');
        }
      }
      
      // Crear sliders para cada morph target
      function createMorphSliders() {
        const morphControls = document.getElementById('morphControls');
        const morphTargets = enemyMorphController.getMorphTargets();
        
        morphControls.innerHTML = '';
        
        Object.keys(morphTargets).forEach(key => {
          const control = document.createElement('div');
          control.className = 'morph-control';
          
          const label = document.createElement('label');
          label.innerHTML = `${key} <span class="morph-value" id="value-${key}">0.00</span>`;
          
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.className = 'morph-slider';
          slider.min = '0';
          slider.max = '100';
          slider.value = '0';
          slider.dataset.morphKey = key;
          
          slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value) / 100;
            enemyMorphController.setMorphTarget(key, value);
            document.getElementById(`value-${key}`).textContent = value.toFixed(2);
          });
          
          control.appendChild(label);
          control.appendChild(slider);
          morphControls.appendChild(control);
        });
      }
      
      // Actualizar estado visual
      function updateStatus(status) {
        const statusEl = document.getElementById('morphStatus');
        
        if (status === 'ready') {
          statusEl.textContent = '‚úÖ Sistema listo';
          statusEl.classList.add('ready');
        } else if (status === 'error') {
          statusEl.textContent = '‚ùå Error al cargar';
          statusEl.classList.remove('ready');
        }
      }
      
      // Actualizar bot√≥n activo
      function updateActiveButton(expression) {
        document.querySelectorAll('.expression-btn').forEach(btn => {
          btn.classList.remove('active');
          if (btn.dataset.expression === expression) {
            btn.classList.add('active');
          }
        });
      }
      
      // Event listeners para botones de expresi√≥n
      document.querySelectorAll('.expression-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const expression = btn.dataset.expression;
          
          if (enemyMorphController && enemyMorphController.isReady) {
            enemyMorphController.setExpression(expression, 300);
            
            // Actualizar sliders para reflejar la expresi√≥n
            setTimeout(() => {
              updateSlidersFromCurrentExpression(expression);
            }, 350);
          }
        });
      });
      
      // Actualizar sliders seg√∫n la expresi√≥n actual
      function updateSlidersFromCurrentExpression(expressionName) {
        if (!enemyMorphController || !enemyMorphController.isReady) return;
        if (!expressionName) {
          console.warn('‚ö†Ô∏è No se especific√≥ nombre de expresi√≥n');
          return;
        }
        
        const expression = enemyMorphController.expressions[expressionName];
        
        if (!expression) {
          console.warn(`‚ö†Ô∏è Expresi√≥n "${expressionName}" no existe`);
          return;
        }
        
        if (expression) {
          Object.keys(expression).forEach(key => {
            const slider = document.querySelector(`[data-morph-key="${key}"]`);
            const valueEl = document.getElementById(`value-${key}`);
            
            if (slider && valueEl) {
              const value = expression[key] || 0;
              slider.value = value * 100;
              valueEl.textContent = value.toFixed(2);
            }
          });
        }
      }
      
      // Bot√≥n de diagn√≥stico
      document.getElementById('diagnosticBtn').addEventListener('click', () => {
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üîç DIAGN√ìSTICO DE MORPH TARGETS');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        const enemy = document.getElementById('enemy');
        
        if (!enemy) {
          console.error('‚ùå No se encontr√≥ la entidad "enemy"');
          return;
        }
        
        console.log('üì¶ Entidad enemy:', enemy);
        console.log('üì¶ Has loaded:', enemy.hasLoaded);
        
        const model = enemy.getObject3D('mesh');
        console.log('üì¶ Objeto 3D (mesh):', model);
        
        if (!model) {
          console.error('‚ùå No hay modelo 3D cargado');
          console.error('üí° Espera unos segundos m√°s o recarga la p√°gina');
          return;
        }
        
        console.log('\nüîç Inspeccionando estructura del modelo...\n');
        let foundMeshes = 0;
        let meshesWithMorphs = 0;
        
        model.traverse((node) => {
          if (node.isMesh) {
            foundMeshes++;
            console.log(`\nüì¶ Mesh #${foundMeshes}: "${node.name || 'sin nombre'}"`);
            console.log('   Tipo:', node.type);
            console.log('   Geometr√≠a:', node.geometry);
            console.log('   Material:', node.material?.name || 'sin nombre');
            
            if (node.morphTargetDictionary) {
              meshesWithMorphs++;
              console.log('   ‚úÖ TIENE MORPH TARGETS:');
              console.log('      Dictionary:', node.morphTargetDictionary);
              console.log('      Influences:', node.morphTargetInfluences);
              console.log('      Cantidad:', Object.keys(node.morphTargetDictionary).length);
            } else {
              console.log('   ‚ùå NO tiene morphTargetDictionary');
            }
            
            if (!node.morphTargetInfluences) {
              console.log('   ‚ùå NO tiene morphTargetInfluences');
            }
          }
        });
        
        console.log(`\nüìä RESUMEN:`);
        console.log(`   Meshes encontrados: ${foundMeshes}`);
        console.log(`   Meshes con morph targets: ${meshesWithMorphs}`);
        
        if (meshesWithMorphs === 0) {
          console.log('\n‚ùå NO SE ENCONTRARON MORPH TARGETS');
          console.log('\nüí° SOLUCI√ìN:');
          console.log('   1. Abre tu modelo en Blender');
          console.log('   2. Verifica que tenga Shape Keys en Object Data Properties');
          console.log('   3. Exporta como GLB con estas opciones:');
          console.log('      - Pesta√±a Animation: ‚òëÔ∏è Animation');
          console.log('      - Pesta√±a Animation: ‚òëÔ∏è Shape Keys ‚¨ÖÔ∏è CR√çTICO');
          console.log('      - Pesta√±a Animation: ‚òëÔ∏è Shape Key Normals');
          console.log('      - Pesta√±a Animation: ‚òëÔ∏è Shape Key Tangents');
          console.log('   4. Lee la gu√≠a: docs/BLENDER_SHAPE_KEYS_EXPORT.md');
          console.log('\nüåê Verifica tu modelo en:');
          console.log('   https://gltf-viewer.donmccurdy.com/');
        } else {
          console.log('\n‚úÖ MODELO CORRECTO - Morph targets detectados');
          
          if (enemyMorphController) {
            console.log('\nüé≠ Estado del controlador:');
            console.log('   isReady:', enemyMorphController.isReady);
            console.log('   currentExpression:', enemyMorphController.currentExpression);
            console.log('   Expresiones disponibles:', Object.keys(enemyMorphController.expressions));
          }
        }
        
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
      });
      
      // Exponer globalmente para debugging
      window.enemyMorphController = enemyMorphController;
      window.morphTargetManager = morphTargetManager;
    </script>
  </body>
</html>        