<!-- Interfaz hecha por chat -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Map Gen Pro Tester
    </title>
    <style>
      :root {
        --bg-0: #0b0d12;
        --bg-1: #121722;
        --panel: #151c28;
        --panel-2: #1c2432;
        --text: #e7e3d9;
        --muted: #9aa3ad;
        --accent: #f7b32b;
        --accent-2: #2dd4bf;
        --danger: #ef4444;
        --grid: rgba(255, 255, 255, 0.08);
        --shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
      }
      * {
        box-sizing: border-box;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        color: var(--text);
        font-family: "Space Grotesk", "Fira Sans", "Trebuchet MS", sans-serif;
        background:          radial-gradient(900px 500px at 10% -10%, rgba(247, 179, 43, 0.12), transparent 60%),          radial-gradient(700px 400px at 120% 20%, rgba(45, 212, 191, 0.12), transparent 60%),          linear-gradient(180deg, var(--bg-0), var(--bg-1));
      }
      .app {
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 16px;
        padding: 16px;
        height: 100%;
      }
      .panel {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent 35%), var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.05);
        box-shadow: var(--shadow);
        border-radius: 16px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        animation: rise 320ms ease-out;
      }
      .panel h1 {
        font-size: 20px;
        margin: 0;
        letter-spacing: 0.4px;
      }
      .section {
        background: var(--panel-2);
        border: 1px solid rgba(255, 255, 255, 0.04);
        border-radius: 12px;
        padding: 12px;
        display: grid;
        gap: 10px;
      }
      .template {
        display: grid;
        gap: 8px;
      }
      .template.disabled {
        opacity: 0.6;
      }
      .template.disabled canvas,      .template.disabled .template-tools {
        pointer-events: none;
      }
      .template canvas {
        width: 160px;
        height: 160px;
        background: #b8bdc3;
        border: 1px solid rgba(0, 0, 0, 0.35);
        border-radius: 8px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      .template-tools {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: center;
      }
      .template small {
        color: var(--muted);
        font-size: 11px;
      }
      .section h2 {
        font-size: 13px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 1.2px;
        margin: 0 0 4px 0;
      }
      .subhead {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--muted);
        margin-top: 2px;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
        display: grid;
        gap: 6px;
      }
      .option-list {
        display: grid;
        gap: 8px;
      }
      .option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 10px;
        background: #10151d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        color: var(--text);
        font-size: 12px;
      }
      .option span {
        color: var(--text);
      }
      input, select, button {
        font: inherit;
        color: var(--text);
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 8px 10px;
      }
      input[type="checkbox"] {
        accent-color: var(--accent);
      }
      input[type="range"] {
        padding: 0;
      }
      button {
        cursor: pointer;
        background: linear-gradient(135deg, rgba(247, 179, 43, 0.2), rgba(45, 212, 191, 0.18));
        border: 1px solid rgba(247, 179, 43, 0.4);
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      }
      button.secondary {
        background: rgba(255, 255, 255, 0.04);
        border-color: rgba(255, 255, 255, 0.1);
      }
      .viewer {
        position: relative;
        background: #0a0d13;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        overflow: hidden;
        display: grid;
        grid-template-rows: auto 1fr;
        box-shadow: var(--shadow);
        animation: rise 360ms ease-out;
      }
      .toolbar {
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 10px 14px;
        background: rgba(10, 13, 19, 0.8);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      .toolbar span {
        font-size: 12px;
        color: var(--muted);
      }
      .canvas-wrap {
        position: relative;
        height: 100%;
        width: 100%;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: #9aa0a6;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        cursor: grab;
      }
      canvas:active {
        cursor: grabbing;
      }
      .hud {
        position: absolute;
        right: 12px;
        bottom: 12px;
        background: rgba(10, 13, 19, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        color: var(--muted);
        min-width: 160px;
      }
      .badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.04);
        margin-right: 6px;
      }
      .hidden {
        display: none !important;
      }
      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
          height: auto;
        }
        .viewer {
          min-height: 60vh;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <aside class="panel">
        <h1>
          Map Gen Pro Tester
        </h1>
        <div class="section">
          <h2>
            Modo
          </h2>
          <label>
            Generador
            <select id="mode">
              <option value="finite">
                Mapa finito
              </option>
              <option value="endless">
                Endless por chunks
              </option>
            </select>
          </label>
        </div>
        <div class="section" data-mode="finite">
          <h2>
            Mapa finito
          </h2>
          <div class="row">
            <label>
              Tamano X
              <input id="width" type="number" min="5" step="2" value="101" />
            </label>
            <label>
              Tamano Y
              <input id="height" type="number" min="5" step="2" value="101" />
            </label>
          </div>
          <label>
            Seed (numero o texto)
            <input id="seed" type="text" placeholder="auto" />
          </label>
          <label>
            BlockType
            <input id="blockType" type="text" value="a_Frame" />
          </label>
          <div class="subhead">
            Bordes
          </div>
          <div class="option-list">
            <label class="option">
              <span>
                Titanic mode
              </span>
              <input id="titanic" type="checkbox" />
            </label>
            <label class="option">
              <span>
                Sin bordes
              </span>
              <input id="noBorders" type="checkbox" />
            </label>
            <label class="option">
              <span>
                Pacmanize
              </span>
              <input id="pacmanize" type="checkbox" />
            </label>
          </div>
          <div class="row">
            <label>
              Titanic chunk size
              <input id="titanicChunkSize" type="number" min="32" step="1" value="256" />
            </label>
            <label>
              Max BFS steps
              <input id="maxBfsStepsTitanic" type="number" min="100000" step="10000" value="2000000" />
            </label>
          </div>
        </div>
        <div class="section hidden" data-mode="endless">
          <h2>
            Endless
          </h2>
          <div class="row">
            <label>
              Chunk size
              <input id="chunkSize" type="number" min="9" step="2" value="65" />
            </label>
            <label>
              Seed (numero o texto)
              <input id="endlessSeed" type="text" placeholder="auto" />
            </label>
          </div>
          <div class="row">
            <label>
              Wall value
              <input id="endlessWall" type="number" value="1" />
            </label>
            <label>
              Path value
              <input id="endlessPath" type="number" value="0" />
            </label>
          </div>
          <label>
            Cache limit (LRU)
            <input id="cacheLimit" type="number" min="8" step="1" value="256" />
          </label>
        </div>
        <div class="section" id="roomsSection">
          <h2>
            Salas
          </h2>
          <div class="row">
            <label>
              Loop chance
              <input id="loopChance" type="number" min="0" max="1" step="0.01" value="0.06" />
            </label>
            <label>
              Room attempts (0 = auto finito)
              <input id="roomAttempts" type="number" min="0" step="1" value="0" />
            </label>
          </div>
          <div class="row">
            <label>
              Room min size
              <input id="roomMinSize" type="number" min="1" step="1" value="3" />
            </label>
            <label>
              Room max size
              <input id="roomMaxSize" type="number" min="1" step="1" value="9" />
            </label>
          </div>
          <div class="option-list">
            <label class="option">
              <span>
                Usar plantilla 16x16
              </span>
              <input id="useRoomTemplate" type="checkbox" />
            </label>
            <label class="option">
              <span>
                Forzar figura (aplica muros)
              </span>
              <input id="forceRoomTemplate" type="checkbox" />
            </label>
          </div>
          <label>
            Brush
            <select id="roomBrush">
              <option value="1">
                Transitable
              </option>
              <option value="2">
                Muro
              </option>
              <option value="3">
                Entrada
              </option>
              <option value="0">
                Borrar
              </option>
            </select>
          </label>
          <div class="template" id="roomTemplateWrap">
            <canvas id="roomTemplate" width="160" height="160">
            </canvas>
            <div class="template-tools">
              <button id="roomClear" class="secondary" type="button">
                Clear
              </button>
              <button id="roomFill" class="secondary" type="button">
                Fill
              </button>
              <button id="roomInvert" class="secondary" type="button">
                Invert
              </button>
              <button id="roomRect" class="secondary" type="button">
                Rect
              </button>
              <small>
                Click: pinta, arrastra para rellenar.
              </small>
            </div>
          </div>
        </div>
        <div class="section" id="goalsSection">
          <h2>
            Objetivos
          </h2>
          <label>
            Modo
            <select id="goalMode">
              <option value="auto_all">
                Auto: Entrada/Salida + Inicio/Fin
              </option>
              <option value="auto_entrance_exit">
                Auto: Entrada/Salida
              </option>
              <option value="auto_start_end">
                Auto: Inicio/Fin
              </option>
              <option value="manual">
                Manual
              </option>
            </select>
          </label>
          <div class="option-list">
            <label class="option">
              <span>
                Marcar celdas
              </span>
              <input id="markCells" type="checkbox" checked />
            </label>
            <label class="option">
              <span>
                Permitir mismo E/S
              </span>
              <input id="allowSame" type="checkbox" />
            </label>
            <label class="option">
              <span>
                Regenerar bordes al crear E/S
              </span>
              <input id="resetBorders" type="checkbox" checked />
            </label>
          </div>
          <div id="manualGoals">
            <div class="row">
              <label>
                Entrada X
                <input id="entranceX" type="number" min="0" step="1" />
              </label>
              <label>
                Entrada Y
                <input id="entranceY" type="number" min="0" step="1" />
              </label>
            </div>
            <div class="row">
              <label>
                Salida X
                <input id="exitX" type="number" min="0" step="1" />
              </label>
              <label>
                Salida Y
                <input id="exitY" type="number" min="0" step="1" />
              </label>
            </div>
            <div class="row">
              <label>
                Inicio X
                <input id="startX" type="number" min="0" step="1" />
              </label>
              <label>
                Inicio Y
                <input id="startY" type="number" min="0" step="1" />
              </label>
            </div>
            <div class="row">
              <label>
                Fin X
                <input id="endX" type="number" min="0" step="1" />
              </label>
              <label>
                Fin Y
                <input id="endY" type="number" min="0" step="1" />
              </label>
            </div>
          </div>
          <div class="row">
            <button id="applyGoals" type="button">
              Generar objetivos
            </button>
            <button id="clearGoals" type="button" class="secondary">
              Limpiar objetivos
            </button>
          </div>
        </div>
        <div class="section">
          <h2>
            Vista
          </h2>
          <div class="row">
            <label>
              Cell size
              <input id="cellSize" type="number" min="2" max="64" value="8" />
            </label>
            <label>
              Zoom
              <input id="zoom" type="range" min="0.2" max="6" value="1" step="0.05" />
            </label>
          </div>
          <div class="row">
            <label>
              Wheel mode
              <select id="wheelMode">
                <option value="pan">
                  Pan (recomendado)
                </option>
                <option value="zoom">
                  Zoom
                </option>
              </select>
            </label>
            <label>
              Max draw cells
              <input id="maxDrawCells" type="number" min="50000" step="50000" value="1500000" />
            </label>
          </div>
          <label>
            Preview tipo de bloque
            <select id="blockPreview">
              <option value="normal">
                Normal
              </option>
              <option value="todos">
                Todos (colores)
              </option>
              <option value="direccion">
                Direcci√≥n
              </option>
              <option value="unilateral">
                Borde unilateral
              </option>
              <option value="bilateral">
                Borde bilateral
              </option>
              <option value="trilateral">
                Borde trilateral
              </option>
              <option value="sin_bordes">
                Sin bordes (4 vecinos)
              </option>
              <option value="completo">
                Completos (0 vecinos)
              </option>
              <option value="esquina">
                Borde esquina
              </option>
            </select>
          </label>
          <div class="row">
            <label>
              <span>
                Show grid
              </span>
              <input id="showGrid" type="checkbox" />
            </label>
            <label>
              <span>
                Fit on generate
              </span>
              <input id="fitOnGenerate" type="checkbox" checked />
            </label>
          </div>
        </div>
        <div class="section">
          <h2>
            Acciones
          </h2>
          <div class="row">
            <button id="generate">
              Generar
            </button>
            <button id="randomSeed" class="secondary">
              Seed random
            </button>
          </div>
          <div class="row">
            <button id="centerMap" class="secondary">
              Centrar mapa
            </button>
            <button id="centerStart" class="secondary">
              Centrar start
            </button>
          </div>
        </div>
      </aside>
      <section class="viewer">
        <div class="toolbar">
          <span id="status" class="badge">
            idle
          </span>
          <span id="stats">
            0 x 0
          </span>
        </div>
        <div class="canvas-wrap">
          <canvas id="view">
          </canvas>
          <div class="hud" id="hud">
          </div>
        </div>
      </section>
    </div>
    <script type="module">
      import {
        MapGenerator, EndlessMaze, CELL
      }
      from '../world/map_generation/map_gen.js';
      const $ = (sel) => document.querySelector(sel);
      const ui = {
        mode: $('#mode'),        width: $('#width'),        height: $('#height'),        seed: $('#seed'),        blockType: $('#blockType'),        titanic: $('#titanic'),        titanicChunkSize: $('#titanicChunkSize'),        maxBfsStepsTitanic: $('#maxBfsStepsTitanic'),        noBorders: $('#noBorders'),        pacmanize: $('#pacmanize'),        markCells: $('#markCells'),        allowSame: $('#allowSame'),        resetBorders: $('#resetBorders'),        goalMode: $('#goalMode'),        manualGoals: $('#manualGoals'),        entranceX: $('#entranceX'),        entranceY: $('#entranceY'),        exitX: $('#exitX'),        exitY: $('#exitY'),        startX: $('#startX'),        startY: $('#startY'),        endX: $('#endX'),        endY: $('#endY'),        applyGoals: $('#applyGoals'),        clearGoals: $('#clearGoals'),        chunkSize: $('#chunkSize'),        endlessSeed: $('#endlessSeed'),        endlessWall: $('#endlessWall'),        endlessPath: $('#endlessPath'),        cacheLimit: $('#cacheLimit'),        loopChance: $('#loopChance'),        roomAttempts: $('#roomAttempts'),        roomMinSize: $('#roomMinSize'),        roomMaxSize: $('#roomMaxSize'),        useRoomTemplate: $('#useRoomTemplate'),        forceRoomTemplate: $('#forceRoomTemplate'),        roomBrush: $('#roomBrush'),        roomTemplate: $('#roomTemplate'),        roomTemplateWrap: $('#roomTemplateWrap'),        roomClear: $('#roomClear'),        roomFill: $('#roomFill'),        roomInvert: $('#roomInvert'),        roomRect: $('#roomRect'),        goalsSection: $('#goalsSection'),        cellSize: $('#cellSize'),        zoom: $('#zoom'),        wheelMode: $('#wheelMode'),        maxDrawCells: $('#maxDrawCells'),        blockPreview: $('#blockPreview'),        showGrid: $('#showGrid'),        fitOnGenerate: $('#fitOnGenerate'),        generate: $('#generate'),        randomSeed: $('#randomSeed'),        centerMap: $('#centerMap'),        centerStart: $('#centerStart'),        status: $('#status'),        stats: $('#stats'),        hud: $('#hud'),
      };
      const canvas = $('#view');
      const ctx = canvas.getContext('2d');
      const state = {
        mode: 'finite',        gen: null,        maze: null,        map: null,        width: 0,        height: 0,        meta: null,        wallValue: 1,        pathValue: 0,        cellSize: 8,        zoom: 1,        offsetX: 0,        offsetY: 0,        pointer: {
          x: 0, y: 0, worldX: 0, worldY: 0
        },        isDragging: false,        dragStart: {
          x: 0, y: 0, ox: 0, oy: 0
        },        raster: null,        lastGenMs: 0,        lastRasterMs: 0,        lastRenderMs: 0,        maxDrawCells: 1_500_000,        wheelMode: 'pan',        showGrid: false,        blockPreview: 'normal',
      };
      const COLORS = {
        wall: [0, 0, 0, 255],        path: [255, 255, 255, 255],        entrance: [34, 197, 94, 255],        exit: [249, 115, 22, 255],        start: [37, 99, 235, 255],        end: [220, 38, 38, 255],        unknown: [120, 120, 120, 255],        highlight: [247, 179, 43, 255],
      };
      const TYPE_COLORS = {
        unilateral: [239, 68, 68, 255],        bilateral: [59, 130, 246, 255],        trilateral: [34, 197, 94, 255],        esquina: [168, 85, 247, 255],        sin_bordes: [14, 165, 233, 255],        completo: [250, 204, 21, 255],
      };
      const DIR_COLORS = {
        N: [59, 130, 246, 255],        NE: [14, 165, 233, 255],        E: [34, 197, 94, 255],        SE: [132, 204, 22, 255],        S: [250, 204, 21, 255],        SW: [249, 115, 22, 255],        W: [239, 68, 68, 255],        NW: [168, 85, 247, 255],        NS: [56, 189, 248, 255],        EW: [248, 113, 113, 255],        solid: [60, 60, 60, 255],        isolated: [255, 255, 255, 255],        center: [120, 120, 120, 255],
      };
      const TEMPLATE_SIZE = 16;
      const templateData = new Uint8Array(TEMPLATE_SIZE * TEMPLATE_SIZE);
      const templateCanvas = ui.roomTemplate;
      const templateCtx = templateCanvas.getContext('2d');
      let templateDrawing = false;
      let templateDrawValue = 1;
      const TEMPLATE_COLORS = {
        1: '#ffffff',        2: '#000000',        3: '#22c55e',
      };
      function currentBrushValue() {
        const v = Number(ui.roomBrush.value);
        return Number.isFinite(v) ? v : 1;
      }
      function fillTemplateRect(pad = 3) {
        templateData.fill(0);
        const x0 = Math.max(0, pad);
        const y0 = Math.max(0, pad);
        const x1 = Math.min(TEMPLATE_SIZE, TEMPLATE_SIZE - pad);
        const y1 = Math.min(TEMPLATE_SIZE, TEMPLATE_SIZE - pad);
        for (let y = y0;
        y < y1;
        y++) {
          for (let x = x0;
          x < x1;
          x++) {
            templateData[y * TEMPLATE_SIZE + x] = 1;
          }
        }
        renderTemplate();
      }
      function renderTemplate() {
        const size = TEMPLATE_SIZE;
        const cell = templateCanvas.width / size;
        templateCtx.clearRect(0, 0, templateCanvas.width, templateCanvas.height);
        templateCtx.fillStyle = '#b8bdc3';
        templateCtx.fillRect(0, 0, templateCanvas.width, templateCanvas.height);
        for (let y = 0;
        y < size;
        y++) {
          for (let x = 0;
          x < size;
          x++) {
            const v = templateData[y * size + x];
            if (!v) continue;
            templateCtx.fillStyle = TEMPLATE_COLORS[v] || '#ffffff';
            templateCtx.fillRect(x * cell, y * cell, cell, cell);
          }
        }
        templateCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        templateCtx.lineWidth = 1;
        for (let i = 0;
        i <= size;
        i++) {
          const p = i * cell;
          templateCtx.beginPath();
          templateCtx.moveTo(p, 0);
          templateCtx.lineTo(p, templateCanvas.height);
          templateCtx.stroke();
          templateCtx.beginPath();
          templateCtx.moveTo(0, p);
          templateCtx.lineTo(templateCanvas.width, p);
          templateCtx.stroke();
        }
      }
      function templateIndexFromEvent(e) {
        const rect = templateCanvas.getBoundingClientRect();
        const x = Math.floor(((e.clientX - rect.left) / rect.width) * TEMPLATE_SIZE);
        const y = Math.floor(((e.clientY - rect.top) / rect.height) * TEMPLATE_SIZE);
        if (x < 0 || y < 0 || x >= TEMPLATE_SIZE || y >= TEMPLATE_SIZE) return -1;
        return y * TEMPLATE_SIZE + x;
      }
      templateCanvas.addEventListener('pointerdown', (e) => {
        if (!ui.useRoomTemplate.checked) return;
        const idx = templateIndexFromEvent(e);
        if (idx < 0) return;
        templateDrawing = true;
        templateDrawValue = currentBrushValue();
        templateData[idx] = templateDrawValue;
        renderTemplate();
        templateCanvas.setPointerCapture(e.pointerId);
      });
      templateCanvas.addEventListener('pointermove', (e) => {
        if (!templateDrawing || !ui.useRoomTemplate.checked) return;
        const idx = templateIndexFromEvent(e);
        if (idx < 0) return;
        if (templateData[idx] !== templateDrawValue) {
          templateData[idx] = templateDrawValue;
          renderTemplate();
        }
      });
      templateCanvas.addEventListener('pointerup', (e) => {
        templateDrawing = false;
        templateCanvas.releasePointerCapture(e.pointerId);
      });
      templateCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
      function parseNumber(el, fallback, min = -Infinity, max = Infinity) {
        const v = Number(el.value);
        if (!Number.isFinite(v)) return fallback;
        return Math.max(min, Math.min(max, v));
      }
      function parseSeed(value) {
        const v = String(value ?? '').trim();
        return v === '' ? null : v;
      }
      function setStatus(text) {
        ui.status.textContent = text;
      }
      function updateStats() {
        const size = state.mode === 'finite'          ? `${state.width} x ${state.height}`          : `chunk ${state.maze?.chunkSize ?? 0}`;
        ui.stats.textContent = `${size} | gen ${state.lastGenMs.toFixed(1)}ms | raster ${state.lastRasterMs.toFixed(1)}ms`;
      }
      function calcAutoRoomAttempts(w, h) {
        const base = Math.round((w * h) / 2500);
        return Math.max(1, Math.min(200, base));
      }
      function parseCoord(el) {
        const raw = String(el.value ?? '').trim();
        if (raw === '') return null;
        const n = Number(raw);
        if (!Number.isFinite(n)) return null;
        return Math.floor(n);
      }
      function parseCoordPair(xEl, yEl) {
        const x = parseCoord(xEl);
        const y = parseCoord(yEl);
        if (x == null || y == null) return null;
        return {
          x, y
        };
      }
      function updateHud() {
        ui.hud.innerHTML = `          <div><span class="badge">${state.mode}</span> zoom ${state.zoom.toFixed(2)} | cell ${state.cellSize}px</div>          <div>offset ${state.offsetX.toFixed(1)}, ${state.offsetY.toFixed(1)}</div>          <div>cursor ${state.pointer.worldX.toFixed(1)}, ${state.pointer.worldY.toFixed(1)}</div>        `;
      }
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const nextW = Math.max(1, Math.floor(rect.width * dpr));
        const nextH = Math.max(1, Math.floor(rect.height * dpr));
        if (canvas.width !== nextW || canvas.height !== nextH) {
          canvas.width = nextW;
          canvas.height = nextH;
        }
      }
      function requestRender() {
        if (state._raf) return;
        state._raf = requestAnimationFrame(() => {
          state._raf = null;
          render();
        });
      }
      function buildRaster() {
        state.raster = null;
        state.lastRasterMs = 0;
        if (!state.map) return;
        const total = state.width * state.height;
        const limit = state.maxDrawCells * 4;
        if (total > limit) return;
        const t0 = performance.now();
        const raster = document.createElement('canvas');
        raster.width = state.width;
        raster.height = state.height;
        const rctx = raster.getContext('2d', {
          willReadFrequently: false
        });
        const img = rctx.createImageData(state.width, state.height);
        const data = img.data;
        for (let i = 0;
        i < state.map.length;
        i++) {
          const v = state.map[i];
          const x = i % state.width;
          const y = (i / state.width) | 0;
          const color = colorForValue(v, x, y);
          const o = i * 4;
          data[o] = color[0];
          data[o + 1] = color[1];
          data[o + 2] = color[2];
          data[o + 3] = color[3];
        }
        rctx.putImageData(img, 0, 0);
        state.raster = raster;
        state.lastRasterMs = performance.now() - t0;
      }
      function colorForValue(v, x, y) {
        if (state.mode === 'endless') {
          if (v === state.wallValue) {
            return colorForWall(x, y);
          }
          if (v === state.pathValue) return COLORS.path;
          return COLORS.unknown;
        }
        if (v === CELL.WALL) {
          return colorForWall(x, y);
        }
        if (v === CELL.PATH) return COLORS.path;
        if (v === CELL.ENTRANCE) return COLORS.entrance;
        if (v === CELL.EXIT) return COLORS.exit;
        if (v === CELL.START) return COLORS.start;
        if (v === CELL.END) return COLORS.end;
        return COLORS.unknown;
      }
      function colorForWall(x, y) {
        const info = wallInfoAt(x, y);
        if (!info) return COLORS.wall;
        if (state.blockPreview === 'todos') {
          return TYPE_COLORS[info.type] || COLORS.wall;
        }
        if (state.blockPreview === 'direccion') {
          return DIR_COLORS[info.direction] || COLORS.wall;
        }
        if (state.blockPreview !== 'normal') {
          if (info.type === state.blockPreview) return COLORS.highlight;
        }
        return COLORS.wall;
      }
      function wallInfoAt(x, y) {
        const v = getCellValue(x, y);
        if (v == null) return null;
        const isWall = isWallValue(v);
        if (!isWall) return null;
        const isWallN = isWallAt(x, y - 1);
        const isWallS = isWallAt(x, y + 1);
        const isWallW = isWallAt(x - 1, y);
        const isWallE = isWallAt(x + 1, y);
        const openN = !isWallN;
        const openS = !isWallS;
        const openW = !isWallW;
        const openE = !isWallE;
        const openCount = (openN ? 1 : 0) + (openS ? 1 : 0) + (openW ? 1 : 0) + (openE ? 1 : 0);
        let type;
        if (openCount === 0) type = 'sin_bordes';
        else if (openCount === 1) type = 'unilateral';
        else if (openCount === 2) {
          const straight = (openN && openS) || (openE && openW);
          type = straight ? 'bilateral' : 'esquina';
        }
        else if (openCount === 3) type = 'trilateral';
        else type = 'completo';
        let direction = 'center';
        if (openCount === 0) direction = 'solid';
        else if (openCount === 4) direction = 'isolated';
        else if (openN && openS && !openE && !openW) direction = 'NS';
        else if (openE && openW && !openN && !openS) direction = 'EW';
        else {
          const vx = (openE ? 1 : 0) + (openW ? -1 : 0);
          const vy = (openS ? 1 : 0) + (openN ? -1 : 0);
          if (vx === 0 && vy === 0) {
            direction = 'center';
          }
          else {
            const angle = Math.atan2(vy, vx);
            const dirs = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
            const idx = Math.round(((angle + Math.PI) / (2 * Math.PI)) * 8) % 8;
            direction = dirs[idx];
          }
        }
        return {
          type, openN, openE, openS, openW, openCount, direction
        };
      }
      function isWallValue(v) {
        return state.mode === 'endless'          ? v === state.wallValue          : v === CELL.WALL;
      }
      function isWallAt(x, y) {
        const v = getCellValue(x, y);
        if (v == null) return false;
        return isWallValue(v);
      }
      function getCellValue(x, y) {
        if (state.mode === 'endless') return state.maze ? state.maze.getCell(x, y) : null;
        if (!state.map) return null;
        if (x < 0 || x >= state.width || y < 0 || y >= state.height) return null;
        return state.map[y * state.width + x];
      }
      function fitToView() {
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / (state.width || 1);
        const scaleY = rect.height / (state.height || 1);
        const scale = Math.max(0.2, Math.min(6, Math.min(scaleX, scaleY)));
        state.zoom = scale / state.cellSize;
        ui.zoom.value = state.zoom.toFixed(2);
        centerOnCell(state.width / 2, state.height / 2);
      }
      function centerOnCell(cx, cy) {
        const rect = canvas.getBoundingClientRect();
        const scale = state.cellSize * state.zoom;
        state.offsetX = rect.width / 2 - cx * scale;
        state.offsetY = rect.height / 2 - cy * scale;
      }
      function render() {
        resizeCanvas();
        const t0 = performance.now();
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);
        const scale = state.cellSize * state.zoom;
        if (scale <= 0.05) {
          state.lastRenderMs = performance.now() - t0;
          updateHud();
          return;
        }
        if (state.mode === 'finite' && state.raster) {
          ctx.imageSmoothingEnabled = false;
          ctx.setTransform(dpr * scale, 0, 0, dpr * scale, state.offsetX * dpr, state.offsetY * dpr);
          ctx.drawImage(state.raster, 0, 0);
        }
        else {
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          const minX = Math.floor((-state.offsetX) / scale) - 1;
          const minY = Math.floor((-state.offsetY) / scale) - 1;
          const maxX = Math.ceil((rect.width - state.offsetX) / scale) + 1;
          const maxY = Math.ceil((rect.height - state.offsetY) / scale) + 1;
          const clampMinX = state.mode === 'finite' ? Math.max(0, minX) : minX;
          const clampMinY = state.mode === 'finite' ? Math.max(0, minY) : minY;
          const clampMaxX = state.mode === 'finite' ? Math.min(state.width, maxX) : maxX;
          const clampMaxY = state.mode === 'finite' ? Math.min(state.height, maxY) : maxY;
          const cells = Math.max(1, (clampMaxX - clampMinX) * (clampMaxY - clampMinY));
          const step = cells > state.maxDrawCells            ? Math.ceil(Math.sqrt(cells / state.maxDrawCells))            : 1;
          for (let y = clampMinY;
          y < clampMaxY;
          y += step) {
            for (let x = clampMinX;
            x < clampMaxX;
            x += step) {
              const v = getCellValue(x, y);
              if (v == null) continue;
              const color = colorForValue(v, x, y);
              ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
              ctx.fillRect(                state.offsetX + x * scale,                state.offsetY + y * scale,                scale * step,                scale * step              );
            }
          }
          if (state.showGrid && scale >= 8) {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;
            for (let x = clampMinX;
            x <= clampMaxX;
            x++) {
              const sx = state.offsetX + x * scale;
              ctx.beginPath();
              ctx.moveTo(sx, state.offsetY + clampMinY * scale);
              ctx.lineTo(sx, state.offsetY + clampMaxY * scale);
              ctx.stroke();
            }
            for (let y = clampMinY;
            y <= clampMaxY;
            y++) {
              const sy = state.offsetY + y * scale;
              ctx.beginPath();
              ctx.moveTo(state.offsetX + clampMinX * scale, sy);
              ctx.lineTo(state.offsetX + clampMaxX * scale, sy);
              ctx.stroke();
            }
          }
        }
        if (state.mode === 'finite' && state.map) {
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
          ctx.lineWidth = Math.max(1, Math.min(2, scale * 0.08));
          ctx.strokeRect(state.offsetX, state.offsetY, state.width * scale, state.height * scale);
        }
        state.lastRenderMs = performance.now() - t0;
        updateHud();
      }
      function applyModeUI() {
        document.querySelectorAll('[data-mode]').forEach((el) => {
          el.classList.toggle('hidden', el.dataset.mode !== ui.mode.value);
        });
      }
      function updateGoalUI() {
        const isManual = ui.goalMode.value === 'manual';
        ui.manualGoals.classList.toggle('hidden', !isManual);
        const enable = state.mode === 'finite';
        ui.goalsSection.querySelectorAll('input, select, button').forEach((el) => {
          el.disabled = !enable;
        });
        ui.goalMode.disabled = !enable;
        if (enable && ui.noBorders.checked) {
          ui.resetBorders.checked = false;
          ui.resetBorders.disabled = true;
        }
        else if (enable) {
          ui.resetBorders.disabled = false;
        }
      }
      function applyGoals() {
        if (state.mode !== 'finite' || !state.gen) return;
        const gen = state.gen;
        const markCells = ui.markCells.checked;
        const allowSame = ui.allowSame.checked;
        const resetBorders = ui.resetBorders.checked && !ui.noBorders.checked;
        gen.clearGoalMarkers();
        try {
          const mode = ui.goalMode.value;
          if (mode === 'auto_all') {
            gen.autoPlaceGoals({
              markCells, allowSameAsEntranceExit: allowSame, resetBorders
            });
          }
          else if (mode === 'auto_entrance_exit') {
            gen.autoPlaceEntranceExit({
              markCells, resetBorders
            });
          }
          else if (mode === 'auto_start_end') {
            gen.autoPlaceStartEnd({
              markCells, allowSameAsEntranceExit: allowSame
            });
          }
          else {
            const entrance = parseCoordPair(ui.entranceX, ui.entranceY);
            const exit = parseCoordPair(ui.exitX, ui.exitY);
            const start = parseCoordPair(ui.startX, ui.startY);
            const end = parseCoordPair(ui.endX, ui.endY);
            if (resetBorders) gen.regenerateBorders();
            gen.setGoals({
              entrance, exit, start, end
            }, {
              markCells
            });
          }
          setStatus('goals');
        }
        catch (err) {
          setStatus('error');
        }
        state.map = gen.getMap();
        state.meta = gen.meta;
        buildRaster();
        requestRender();
      }
      function clearGoals() {
        if (state.mode !== 'finite' || !state.gen) return;
        state.gen.clearGoalMarkers();
        state.map = state.gen.getMap();
        state.meta = state.gen.meta;
        buildRaster();
        requestRender();
      }
      function generateFinite() {
        const t0 = performance.now();
        const gen = new MapGenerator(          parseNumber(ui.width, 101, 5),          parseNumber(ui.height, 101, 5),          {
          blockType: ui.blockType.value || 'a_Frame',            seed: parseSeed(ui.seed.value),            titanic: ui.titanic.checked,            titanicChunkSize: parseNumber(ui.titanicChunkSize, 256, 32),            maxBfsStepsTitanic: parseNumber(ui.maxBfsStepsTitanic, 2_000_000, 100_000),
        });
        const roomAttempts = parseNumber(ui.roomAttempts, 0, 0, 2000);
        const attempts = roomAttempts > 0 ? roomAttempts : calcAutoRoomAttempts(gen.width, gen.height);
        gen.generateMaze({
          ensureBorderWalls: !ui.noBorders.checked,
          carveToBorder: ui.noBorders.checked
        });
        gen.applyRooms({
          attempts,          minSize: parseNumber(ui.roomMinSize, 3, 1),          maxSize: parseNumber(ui.roomMaxSize, 9, 1),          template: ui.useRoomTemplate.checked ? templateData : null,          templateSize: TEMPLATE_SIZE,          forceTemplate: ui.forceRoomTemplate.checked,
        });
        if (ui.pacmanize.checked) {
          gen.pacmanizeMap();
        }
        state.gen = gen;
        state.maze = null;
        state.map = gen.getMap();
        state.width = gen.width;
        state.height = gen.height;
        state.meta = gen.meta;
        state.mode = 'finite';
        state.lastGenMs = performance.now() - t0;
        buildRaster();
        if (ui.fitOnGenerate.checked) fitToView();
      }
      function generateEndless() {
        const t0 = performance.now();
        const maze = new EndlessMaze({
          chunkSize: parseNumber(ui.chunkSize, 65, 9),          seed: parseSeed(ui.endlessSeed.value),          wall: parseNumber(ui.endlessWall, 1),          path: parseNumber(ui.endlessPath, 0),          cacheLimit: parseNumber(ui.cacheLimit, 256, 8),          loopChance: parseNumber(ui.loopChance, 0.06, 0, 1),          roomAttempts: parseNumber(ui.roomAttempts, 6, 0, 200),          roomMinSize: parseNumber(ui.roomMinSize, 3, 1),          roomMaxSize: parseNumber(ui.roomMaxSize, 9, 1),          roomTemplate: ui.useRoomTemplate.checked ? templateData : null,          roomTemplateSize: TEMPLATE_SIZE,          forceRoomTemplate: ui.forceRoomTemplate.checked,
        });
        state.gen = null;
        state.maze = maze;
        state.map = null;
        state.width = 0;
        state.height = 0;
        state.meta = null;
        state.mode = 'endless';
        state.wallValue = maze.wall;
        state.pathValue = maze.path;
        state.lastGenMs = performance.now() - t0;
        state.raster = null;
        if (ui.fitOnGenerate.checked) {
          state.zoom = 1;
          ui.zoom.value = state.zoom.toFixed(2);
          centerOnCell(0, 0);
        }
      }
      function generate() {
        setStatus('working');
        state.cellSize = parseNumber(ui.cellSize, 8, 2, 64);
        state.zoom = parseNumber(ui.zoom, 1, 0.2, 6);
        state.maxDrawCells = parseNumber(ui.maxDrawCells, 1_500_000, 50_000);
        state.wheelMode = ui.wheelMode.value;
        state.showGrid = ui.showGrid.checked;
        state.blockPreview = ui.blockPreview.value;
        if (ui.mode.value === 'finite') {
          generateFinite();
        }
        else {
          generateEndless();
        }
        updateGoalUI();
        if (state.mode === 'finite' && ui.goalMode.value !== 'manual') {
          applyGoals();
        }
        setStatus('ready');
        updateStats();
        requestRender();
      }
      function randomizeSeed() {
        const s = Math.floor(Math.random() * 2 ** 31);
        if (ui.mode.value === 'finite') ui.seed.value = s;
        else ui.endlessSeed.value = s;
      }
      function panBy(dx, dy) {
        state.offsetX += dx;
        state.offsetY += dy;
        requestRender();
      }
      function zoomAt(factor, cx, cy) {
        const prevZoom = state.zoom;
        const nextZoom = Math.max(0.2, Math.min(6, prevZoom * factor));
        if (nextZoom === prevZoom) return;
        const scale = state.cellSize * prevZoom;
        const worldX = (cx - state.offsetX) / scale;
        const worldY = (cy - state.offsetY) / scale;
        state.zoom = nextZoom;
        ui.zoom.value = state.zoom.toFixed(2);
        const nextScale = state.cellSize * nextZoom;
        state.offsetX = cx - worldX * nextScale;
        state.offsetY = cy - worldY * nextScale;
        requestRender();
      }
      canvas.addEventListener('pointerdown', (e) => {
        state.isDragging = true;
        canvas.setPointerCapture(e.pointerId);
        state.dragStart = {
          x: e.clientX, y: e.clientY, ox: state.offsetX, oy: state.offsetY
        };
      });
      canvas.addEventListener('pointerup', (e) => {
        state.isDragging = false;
        canvas.releasePointerCapture(e.pointerId);
      });
      canvas.addEventListener('pointermove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scale = state.cellSize * state.zoom;
        state.pointer.x = e.clientX - rect.left;
        state.pointer.y = e.clientY - rect.top;
        state.pointer.worldX = (state.pointer.x - state.offsetX) / scale;
        state.pointer.worldY = (state.pointer.y - state.offsetY) / scale;
        if (state.isDragging) {
          state.offsetX = state.dragStart.ox + (e.clientX - state.dragStart.x);
          state.offsetY = state.dragStart.oy + (e.clientY - state.dragStart.y);
          requestRender();
        }
        updateHud();
      });
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        if (state.wheelMode === 'zoom' || e.ctrlKey) {
          const factor = Math.exp(-e.deltaY * 0.0015);
          zoomAt(factor, cx, cy);
        }
        else {
          panBy(-e.deltaX, -e.deltaY);
        }
      }, {
        passive: false
      });
      ui.generate.addEventListener('click', generate);
      ui.randomSeed.addEventListener('click', () => {
        randomizeSeed();
      });
      ui.centerMap.addEventListener('click', () => {
        if (state.mode === 'finite') {
          centerOnCell(state.width / 2, state.height / 2);
        }
        else {
          centerOnCell(0, 0);
        }
        requestRender();
      });
      ui.centerStart.addEventListener('click', () => {
        if (state.mode === 'finite' && state.meta?.start) {
          centerOnCell(state.meta.start.x, state.meta.start.y);
          requestRender();
        }
      });
      ui.mode.addEventListener('change', () => {
        applyModeUI();
        generate();
      });
      ui.goalMode.addEventListener('change', updateGoalUI);
      ui.applyGoals.addEventListener('click', applyGoals);
      ui.clearGoals.addEventListener('click', clearGoals);
      ui.noBorders.addEventListener('change', updateGoalUI);
      function updateTemplateUI() {
        const enabled = ui.useRoomTemplate.checked;
        ui.roomTemplateWrap.classList.toggle('disabled', !enabled);
        ui.roomBrush.disabled = !enabled;
        ui.forceRoomTemplate.disabled = !enabled;
      }
      ui.useRoomTemplate.addEventListener('change', updateTemplateUI);
      ui.roomClear.addEventListener('click', () => {
        templateData.fill(0);
        renderTemplate();
      });
      ui.roomFill.addEventListener('click', () => {
        const v = currentBrushValue();
        templateData.fill(v);
        renderTemplate();
      });
      ui.roomInvert.addEventListener('click', () => {
        for (let i = 0;
        i < templateData.length;
        i++) {
          templateData[i] = templateData[i] ? 0 : 1;
        }
        renderTemplate();
      });
      ui.roomRect.addEventListener('click', () => fillTemplateRect(3));
      ui.roomBrush.addEventListener('change', () => {
        templateDrawValue = currentBrushValue();
      });
      [ui.cellSize, ui.zoom, ui.maxDrawCells, ui.wheelMode, ui.showGrid, ui.blockPreview].forEach((el) => {
        el.addEventListener('input', () => {
          state.cellSize = parseNumber(ui.cellSize, 8, 2, 64);
          state.zoom = parseNumber(ui.zoom, 1, 0.2, 6);
          state.maxDrawCells = parseNumber(ui.maxDrawCells, 1_500_000, 50_000);
          state.wheelMode = ui.wheelMode.value;
          state.showGrid = ui.showGrid.checked;
          state.blockPreview = ui.blockPreview.value;
          buildRaster();
          requestRender();
        });
      });
      window.addEventListener('resize', () => requestRender());
      applyModeUI();
      fillTemplateRect(3);
      updateTemplateUI();
      updateGoalUI();
      generate();
    </script>
  </body>
</html>
