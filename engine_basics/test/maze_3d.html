<!-- Interfaz mitad chat, le cuesta la estructuracion y manejo de los assets, considerar para actualizar o mover cualquier cosa -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Laberinto 3D A-Frame
    </title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js">
    </script>
    <style>
      :root {
        --bg-0: #0b0d12;
        --panel: rgba(16, 21, 29, 0.92);
        --text: #e7e3d9;
        --muted: #9aa3ad;
        --accent: #f7b32b;
        --shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
      }
      * {
        box-sizing: border-box;
      }
      html, body {
        height: 100%;
        margin: 0;
      }
      body {
        font-family: "Space Grotesk", "Fira Sans", sans-serif;
        background: var(--bg-0);
        color: var(--text);
      }
      .ui {
        position: fixed;
        top: 16px;
        left: 16px;
        width: 360px;
        max-height: calc(100vh - 32px);
        overflow: auto;
        background: linear-gradient(180deg, rgba(15, 20, 29, 0.95), rgba(12, 16, 24, 0.9));
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 14px 14px 18px;
        box-shadow: var(--shadow);
        display: grid;
        gap: 12px;
        backdrop-filter: blur(8px);
        z-index: 10;
      }
      .ui h1 {
        font-size: 16px;
        margin: 0 0 8px 0;
        letter-spacing: 0.4px;
      }
      .section {
        display: grid;
        gap: 8px;
        padding: 10px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
      }
      .section h2 {
        font-size: 11px;
        text-transform: uppercase;
        color: var(--muted);
        letter-spacing: 1px;
        margin: 6px 0;
      }
      label {
        display: grid;
        gap: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      input, select, button {
        font: inherit;
        color: var(--text);
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 7px 9px;
        width: 100%;
      }
      input[type="checkbox"] {
        width: auto;
      }
      button {
        cursor: pointer;
        background: linear-gradient(135deg, rgba(247, 179, 43, 0.22), rgba(45, 212, 191, 0.18));
        border: 1px solid rgba(247, 179, 43, 0.4);
      }
      .row {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 8px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
      }
      .option span {
        font-size: 12px;
        color: var(--text);
      }
      .option strong {
        font-size: 12px;
        color: var(--text);
      }
      button.secondary {
        background: rgba(255, 255, 255, 0.04);
        border-color: rgba(255, 255, 255, 0.14);
      }
      .template {
        display: grid;
        gap: 8px;
      }
      .template.disabled {
        opacity: 0.6;
      }
      .template.disabled canvas,      .template.disabled .template-tools {
        pointer-events: none;
      }
      .template canvas {
        width: 160px;
        height: 160px;
        background: #b8bdc3;
        border: 1px solid rgba(0, 0, 0, 0.35);
        border-radius: 8px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      .template-tools {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: center;
      }
      .template small {
        font-size: 11px;
        color: var(--muted);
      }
      .hint {
        font-size: 11px;
        color: var(--muted);
      }
      .hidden {
        display: none !important;
      }
      .preview canvas {
        width: 240px;
        height: 180px;
        background: #0f141d;
      }
      .minimap canvas {
        width: 240px;
        height: 240px;
        background: #0f141d;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      @media (max-width: 700px) {
        .ui {
          width: calc(100% - 32px);
        }
        .row {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="ui">
      <h1>
        Laberinto 3D
      </h1>
      <div class="section">
        <h2>
          Mapa
        </h2>
        <div class="row">
          <label>
            Ancho
            <input id="width" type="number" min="5" step="2" value="41" />
          </label>
          <label>
            Alto
            <input id="height" type="number" min="5" step="2" value="41" />
          </label>
        </div>
        <label>
          Seed
          <input id="seed" type="text" placeholder="auto" />
        </label>
        <div class="option">
          <span>
            Sin bordes
          </span>
          <input id="noBorders" type="checkbox" />
        </div>
        <div class="option">
          <span>
            Pacmanize
          </span>
          <input id="pacmanize" type="checkbox" />
        </div>
      </div>
      <div class="section">
        <h2>
          Salas
        </h2>
        <div class="row">
          <label>
            Attempts (0=auto)
            <input id="roomAttempts" type="number" min="0" step="1" value="0" />
          </label>
          <label>
            Min size
            <input id="roomMin" type="number" min="1" step="1" value="3" />
          </label>
        </div>
        <label>
          Max size
          <input id="roomMax" type="number" min="1" step="1" value="9" />
        </label>
        <div class="option">
          <span>
            Usar plantilla 16x16
          </span>
          <input id="useRoomTemplate" type="checkbox" />
        </div>
        <div class="option">
          <span>
            Forzar figura (aplica muros)
          </span>
          <input id="forceRoomTemplate" type="checkbox" />
        </div>
        <label>
          Brush
          <select id="roomBrush">
            <option value="1">
              Transitable
            </option>
            <option value="2">
              Muro
            </option>
            <option value="3">
              Entrada
            </option>
            <option value="0">
              Borrar
            </option>
          </select>
        </label>
        <div class="template" id="roomTemplateWrap">
          <canvas id="roomTemplate" width="160" height="160">
          </canvas>
          <div class="template-tools">
            <button id="roomClear" class="secondary" type="button">
              Clear
            </button>
            <button id="roomFill" class="secondary" type="button">
              Fill
            </button>
            <button id="roomInvert" class="secondary" type="button">
              Invert
            </button>
            <button id="roomRect" class="secondary" type="button">
              Rect
            </button>
            <small>
              Click: pinta, arrastra para rellenar.
            </small>
          </div>
        </div>
      </div>
      <div class="section">
        <h2>
          Assets
        </h2>
        <div class="row">
          <label>
            Tamano asset (m)
            <input id="assetSize" type="number" min="0.5" step="0.1" value="6" />
          </label>
          <label>
            Escala extra
            <input id="wallScale" type="number" min="0.1" step="0.05" value="1" />
          </label>
        </div>
        <label>
          Origen del modelo
          <select id="assetOrigin">
            <option value="center">
              Centro
            </option>
            <option value="base">
              Base
            </option>
          </select>
        </label>
        <div class="option">
          <span>
            Escala final
          </span>
          <strong id="computedScale">
            1.000
          </strong>
        </div>
        <div class="row">
          <label>
            Unilateral base
            <select id="uniBase">
              <option value="N">
                N
              </option>
              <option value="E">
                E
              </option>
              <option value="S" selected>
                S
              </option>
              <option value="W">
                W
              </option>
            </select>
          </label>
          <label>
            Bilateral base
            <select id="biBase">
              <option value="NS" selected>
                NS
              </option>
              <option value="EW">
                EW
              </option>
            </select>
          </label>
        </div>
        <div class="row">
          <label>
            Esquina base
            <select id="cornerBase">
              <option value="NE">
                NE
              </option>
              <option value="SE" selected>
                SE
              </option>
              <option value="SW">
                SW
              </option>
              <option value="NW">
                NW
              </option>
            </select>
          </label>
          <label>
            Trilateral (lados abiertos)
            <select id="triBase">
              <option value="NSW">
                NSW
              </option>
              <option value="NSE" selected>
                NSE
              </option>
              <option value="WES">
                WES
              </option>
              <option value="WEN">
                WEN
              </option>
            </select>
          </label>
        </div>
        <div class="template preview">
          <canvas id="assetPreview" width="240" height="180">
          </canvas>
          <small>
            Preview: lados abiertos (verde), cerrados (gris). Flecha = Norte.
          </small>
        </div>
      </div>
      <div class="section minimap">
        <h2>
          Minimap
        </h2>
        <canvas id="minimap" width="220" height="220">
        </canvas>
        <small>
          Vista general del laberinto (click en Generar para actualizar).
        </small>
      </div>
      <div class="section">
        <h2>
          Objetivos
        </h2>
        <label>
          Modo
          <select id="goalMode">
            <option value="auto_all">
              Auto: Entrada/Salida + Inicio/Fin
            </option>
            <option value="auto_entrance_exit">
              Auto: Entrada/Salida
            </option>
            <option value="auto_start_end">
              Auto: Inicio/Fin
            </option>
            <option value="manual">
              Manual
            </option>
          </select>
        </label>
        <div class="option">
          <span>
            Marcar celdas
          </span>
          <input id="markCells" type="checkbox" checked />
        </div>
        <div class="option">
          <span>
            Permitir mismo E/S
          </span>
          <input id="allowSame" type="checkbox" />
        </div>
        <div class="option">
          <span>
            Regenerar bordes al crear E/S
          </span>
          <input id="resetBorders" type="checkbox" checked />
        </div>
        <div id="manualGoals">
          <div class="row">
            <label>
              Entrada X
              <input id="entranceX" type="number" min="0" step="1" />
            </label>
            <label>
              Entrada Y
              <input id="entranceY" type="number" min="0" step="1" />
            </label>
          </div>
          <div class="row">
            <label>
              Salida X
              <input id="exitX" type="number" min="0" step="1" />
            </label>
            <label>
              Salida Y
              <input id="exitY" type="number" min="0" step="1" />
            </label>
          </div>
          <div class="row">
            <label>
              Inicio X
              <input id="startX" type="number" min="0" step="1" />
            </label>
            <label>
              Inicio Y
              <input id="startY" type="number" min="0" step="1" />
            </label>
          </div>
          <div class="row">
            <label>
              Fin X
              <input id="endX" type="number" min="0" step="1" />
            </label>
            <label>
              Fin Y
              <input id="endY" type="number" min="0" step="1" />
            </label>
          </div>
        </div>
        <div class="row">
          <button id="applyGoals" type="button">
            Generar objetivos
          </button>
          <button id="clearGoals" class="secondary" type="button">
            Limpiar objetivos
          </button>
        </div>
      </div>
      <div class="section">
        <h2>
          3D
        </h2>
        <label>
          Cell size
          <input id="cellSize" type="number" min="0.5" step="0.1" value="6" />
        </label>
        <label>
          Altura muros (capas)
          <input id="wallHeight" type="number" min="1" step="1" value="1" />
        </label>
        <label>
          Yaw offset (grados)
          <input id="yawOffset" type="number" step="5" value="0" />
        </label>
        <div class="option">
          <span>
            Incluir internos
          </span>
          <input id="includeInner" type="checkbox" checked />
        </div>
        <div class="option">
          <span>
            Techar (roof)
          </span>
          <input id="roofEnabled" type="checkbox" />
        </div>
      </div>
      <div class="section">
        <h2>
          Mundos
        </h2>
        <label>
          Nombre
          <input id="worldName" type="text" placeholder="mi_mundo" />
        </label>
        <div class="row">
          <button id="saveWorld" type="button">
            Guardar
          </button>
          <button id="exportWorld" class="secondary" type="button">
            Exportar JSON
          </button>
        </div>
        <label>
          Guardados
          <select id="worldList">
          </select>
        </label>
        <div class="row">
          <button id="loadWorld" type="button">
            Cargar
          </button>
          <button id="deleteWorld" class="secondary" type="button">
            Eliminar
          </button>
        </div>
        <label>
          Importar JSON
          <input id="importWorld" type="file" accept="application/json" />
        </label>
        <div class="hint">
          Se guardan en localStorage y puedes exportar/importar archivos.
        </div>
      </div>
      <div class="section">
        <button id="generate">
          Generar
        </button>
        <div class="hint">
          Controles: WASD + mouse.
        </div>
      </div>
    </div>
    <a-scene background="color: #9aa0a6" renderer="antialias: true; colorManagement: true;">
      <a-assets>
        <a-asset-item id="mdl-unilateral" src="../assets/blocks/unilateral.glb">
        </a-asset-item>
        <a-asset-item id="mdl-bilateral" src="../assets/blocks/bilateral.glb">
        </a-asset-item>
        <a-asset-item id="mdl-corner" src="../assets/blocks/bilateral_corner.glb">
        </a-asset-item>
        <a-asset-item id="mdl-trilateral" src="../assets/blocks/trilateral.glb">
        </a-asset-item>
        <a-asset-item id="mdl-full" src="../assets/blocks/full.glb">
        </a-asset-item>
      </a-assets>
      <a-entity id="rig" position="0 1.6 4">
        <a-entity camera look-controls wasd-controls="acceleration: 40; fly: true">
        </a-entity>
      </a-entity>
      <a-entity light="type: ambient; intensity: 0.6">
      </a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="4 8 2">
      </a-entity>
      <a-plane id="floor" rotation="-90 0 0" width="10" height="10" color="#cfd2d6">
      </a-plane>
      <a-box id="roof" width="10" height="1" depth="10" color="#b2b7be" visible="false"        material="side: back; opacity: 0.98; transparent: false">
      </a-box>
      <a-entity id="maze">
      </a-entity>
      <a-entity id="goals">
      </a-entity>
    </a-scene>
    <script type="module">
      import {
        MapGenerator, CELL
      }
      from '../world/map_generation/map_gen.js';
      import {
        createWorldSnapshot, parseWorld, serializeWorld
      }
      from '../world/world_procesing/world_saver.js';
      const $ = (id) => document.getElementById(id);
      const ui = {
        width: $('width'),        height: $('height'),        seed: $('seed'),        noBorders: $('noBorders'),        pacmanize: $('pacmanize'),        roomAttempts: $('roomAttempts'),        roomMin: $('roomMin'),        roomMax: $('roomMax'),        useRoomTemplate: $('useRoomTemplate'),        forceRoomTemplate: $('forceRoomTemplate'),        roomBrush: $('roomBrush'),        roomTemplate: $('roomTemplate'),        roomTemplateWrap: $('roomTemplateWrap'),        roomClear: $('roomClear'),        roomFill: $('roomFill'),        roomInvert: $('roomInvert'),        roomRect: $('roomRect'),        assetSize: $('assetSize'),        wallScale: $('wallScale'),        assetOrigin: $('assetOrigin'),        computedScale: $('computedScale'),        uniBase: $('uniBase'),        biBase: $('biBase'),        cornerBase: $('cornerBase'),        triBase: $('triBase'),        assetPreview: $('assetPreview'),        minimap: $('minimap'),        goalMode: $('goalMode'),        markCells: $('markCells'),        allowSame: $('allowSame'),        resetBorders: $('resetBorders'),        manualGoals: $('manualGoals'),        entranceX: $('entranceX'),        entranceY: $('entranceY'),        exitX: $('exitX'),        exitY: $('exitY'),        startX: $('startX'),        startY: $('startY'),        endX: $('endX'),        endY: $('endY'),        applyGoals: $('applyGoals'),        clearGoals: $('clearGoals'),        cellSize: $('cellSize'),        wallHeight: $('wallHeight'),        yawOffset: $('yawOffset'),        includeInner: $('includeInner'),        roofEnabled: $('roofEnabled'),        worldName: $('worldName'),        saveWorld: $('saveWorld'),        exportWorld: $('exportWorld'),        worldList: $('worldList'),        loadWorld: $('loadWorld'),        deleteWorld: $('deleteWorld'),        importWorld: $('importWorld'),        generate: $('generate'),
      };
      const mazeEl = document.getElementById('maze');
      const floorEl = document.getElementById('floor');
      const roofEl = document.getElementById('roof');
      const rigEl = document.getElementById('rig');
      const goalsEl = document.getElementById('goals');
      const SIDE = {
        N: 1, E: 2, S: 4, W: 8
      };
      const ROTATE_CW = {
        [SIDE.N]: SIDE.E, [SIDE.E]: SIDE.S, [SIDE.S]: SIDE.W, [SIDE.W]: SIDE.N
      };
      const TRILATERAL_OPTIONS = [        {
        label: 'NSW', open: SIDE.N | SIDE.S | SIDE.W
      },        {
        label: 'NSE', open: SIDE.N | SIDE.S | SIDE.E
      },        {
        label: 'WES', open: SIDE.W | SIDE.E | SIDE.S
      },        {
        label: 'WEN', open: SIDE.W | SIDE.E | SIDE.N
      },      ];
      const CALIB_KEY = 'mazeAssetCalibration';
      const WORLD_KEY = 'mazeWorldLibrary';
      const state = {
        gen: null,        map: null,        width: 0,        height: 0,        cellSize: 6,        wallScale: 1,        wallHeight: 1,        assetSize: 6,        assetOrigin: 'center',        assetBase: {
          unilateral: SIDE.S,          bilateral: SIDE.N | SIDE.S,          corner: SIDE.S | SIDE.E,          trilateral: SIDE.N | SIDE.E | SIDE.S,
        },        assetAdjust: {
          unilateral: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1
          },          bilateral: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1
          },          corner: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1
          },          trilateral: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1
          },          full: {
            pos: {
              x: 0, y: 0, z: 0
            }, rotY: 0, scale: 1
          },
        },        yawOffset: 0,        includeInner: true,        roofEnabled: false,        halfW: 0,        halfH: 0,
      };
      const TEMPLATE_SIZE = 16;
      const templateData = new Uint8Array(TEMPLATE_SIZE * TEMPLATE_SIZE);
      const templateCanvas = ui.roomTemplate;
      const templateCtx = templateCanvas.getContext('2d');
      let templateDrawing = false;
      let templateDrawValue = 1;
      const assetPreviewCanvas = ui.assetPreview;
      const assetPreviewCtx = assetPreviewCanvas.getContext('2d');
      const minimapCanvas = ui.minimap;
      const minimapCtx = minimapCanvas.getContext('2d');
      const TEMPLATE_COLORS = {
        1: '#ffffff',        2: '#000000',        3: '#22c55e',
      };
      const MINIMAP_COLORS = {
        wall: [20, 22, 28, 255],        path: [235, 236, 240, 255],        entrance: [34, 197, 94, 255],        exit: [249, 115, 22, 255],        start: [96, 165, 250, 255],        end: [239, 68, 68, 255],
      };
      function parseNumber(el, fallback, min = -Infinity, max = Infinity) {
        const v = Number(el.value);
        if (!Number.isFinite(v)) return fallback;
        return Math.max(min, Math.min(max, v));
      }
      function loadCalibrationConfig() {
        try {
          const raw = localStorage.getItem(CALIB_KEY);
          if (!raw) return null;
          const cfg = JSON.parse(raw);
          if (!cfg || typeof cfg !== 'object') return null;
          return cfg;
        }
        catch {
          return null;
        }
      }
      function readAdjust(cfg, key) {
        const src = cfg?.adjust?.[key] || {
        };
        const pos = src.pos || {
        };
        return {
          pos: {
            x: Number(pos.x) || 0,            y: Number(pos.y) || 0,            z: Number(pos.z) || 0,
          },          rotY: Number(src.rotY) || 0,          scale: Number(src.scale) || 1,
        };
      }
      function applyCalibrationConfig(cfg) {
        if (!cfg) return false;
        if (Number.isFinite(cfg.assetSize)) ui.assetSize.value = cfg.assetSize;
        if (Number.isFinite(cfg.wallScale)) ui.wallScale.value = cfg.wallScale;
        if (cfg.assetOrigin === 'center' || cfg.assetOrigin === 'base') ui.assetOrigin.value = cfg.assetOrigin;
        if (cfg.base?.unilateral) ui.uniBase.value = cfg.base.unilateral;
        if (cfg.base?.bilateral) ui.biBase.value = cfg.base.bilateral;
        if (cfg.base?.corner) ui.cornerBase.value = cfg.base.corner;
        if (cfg.base?.trilateral) ui.triBase.value = normalizeTrilateralBase(cfg.base.trilateral);
        state.assetAdjust = {
          unilateral: readAdjust(cfg, 'unilateral'),          bilateral: readAdjust(cfg, 'bilateral'),          corner: readAdjust(cfg, 'corner'),          trilateral: readAdjust(cfg, 'trilateral'),          full: readAdjust(cfg, 'full'),
        };
        updateAssetConfig();
        return true;
      }
      function parseSeed(value) {
        const v = String(value ?? '').trim();
        return v === '' ? null : v;
      }
      function loadWorldLibrary() {
        try {
          const raw = localStorage.getItem(WORLD_KEY);
          if (!raw) return {
          };
          const data = JSON.parse(raw);
          return data && typeof data === 'object' ? data : {
          };
        }
        catch {
          return {
          };
        }
      }
      function saveWorldLibrary(lib) {
        localStorage.setItem(WORLD_KEY, JSON.stringify(lib));
      }
      function refreshWorldList(selectedName = null) {
        const lib = loadWorldLibrary();
        const names = Object.keys(lib).sort();
        ui.worldList.innerHTML = '';
        names.forEach((name) => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          if (selectedName && name === selectedName) opt.selected = true;
          ui.worldList.appendChild(opt);
        });
        if (!selectedName && names.length) ui.worldList.value = names[0];
      }
      function cloneAssetAdjust(adjust) {
        const out = {
        };
        Object.keys(adjust || {
        }).forEach((key) => {
          const src = adjust[key] || {
          };
          out[key] = {
            pos: {
              x: Number(src.pos?.x) || 0,              y: Number(src.pos?.y) || 0,              z: Number(src.pos?.z) || 0,
            },            rotY: Number(src.rotY) || 0,            scale: Number(src.scale) || 1,
          };
        });
        return out;
      }
      function buildWorldSnapshot(name) {
        if (!state.gen || !state.gen.map) return null;
        const settings = {
          width: parseNumber(ui.width, state.gen.width, 5),          height: parseNumber(ui.height, state.gen.height, 5),          seed: ui.seed.value || '',          noBorders: ui.noBorders.checked,          pacmanize: ui.pacmanize.checked,          roomAttempts: parseNumber(ui.roomAttempts, 0, 0, 2000),          roomMin: parseNumber(ui.roomMin, 3, 1),          roomMax: parseNumber(ui.roomMax, 9, 1),          useRoomTemplate: ui.useRoomTemplate.checked,          forceRoomTemplate: ui.forceRoomTemplate.checked,          roomBrush: ui.roomBrush.value,
        };
        const view = {
          cellSize: state.cellSize,          wallScale: state.wallScale,          wallHeight: state.wallHeight,          assetSize: state.assetSize,          assetOrigin: state.assetOrigin,          yawOffset: state.yawOffset,          includeInner: state.includeInner,          roofEnabled: state.roofEnabled,
        };
        const assets = {
          base: {
            unilateral: ui.uniBase.value,            bilateral: ui.biBase.value,            corner: ui.cornerBase.value,            trilateral: ui.triBase.value,
          },          adjust: cloneAssetAdjust(state.assetAdjust),
        };
        const template = {
          size: TEMPLATE_SIZE,          data: Array.from(templateData),
        };
        const spawns = {
          items: [], enemies: [], allies: []
        };
        return createWorldSnapshot({
          name,          map: state.gen.map,          width: state.gen.width,          height: state.gen.height,          meta: state.gen.meta,          settings,          view,          assets,          template,          spawns,
        });
      }
      function applyWorldSnapshot(world) {
        const data = (world && world.map instanceof Uint8Array) ? world : parseWorld(world);
        ui.width.value = data.width;
        ui.height.value = data.height;
        if (data.settings) {
          ui.seed.value = data.settings.seed ?? '';
          ui.noBorders.checked = !!data.settings.noBorders;
          ui.pacmanize.checked = !!data.settings.pacmanize;
          ui.roomAttempts.value = data.settings.roomAttempts ?? 0;
          ui.roomMin.value = data.settings.roomMin ?? 3;
          ui.roomMax.value = data.settings.roomMax ?? 9;
          ui.useRoomTemplate.checked = !!data.settings.useRoomTemplate;
          ui.forceRoomTemplate.checked = !!data.settings.forceRoomTemplate;
          if (data.settings.roomBrush != null) ui.roomBrush.value = data.settings.roomBrush;
        }
        if (data.template?.data?.length === TEMPLATE_SIZE * TEMPLATE_SIZE) {
          templateData.set(data.template.data);
          renderTemplate();
        }
        if (data.view) {
          ui.cellSize.value = data.view.cellSize ?? ui.cellSize.value;
          ui.wallScale.value = data.view.wallScale ?? ui.wallScale.value;
          if (data.view.wallHeight != null) {
            ui.wallHeight.value = Math.max(1, Math.round(Number(data.view.wallHeight)));
          }
          ui.assetSize.value = data.view.assetSize ?? ui.assetSize.value;
          if (data.view.assetOrigin) ui.assetOrigin.value = data.view.assetOrigin;
          ui.yawOffset.value = data.view.yawOffset ?? ui.yawOffset.value;
          ui.includeInner.checked = data.view.includeInner ?? ui.includeInner.checked;
          ui.roofEnabled.checked = data.view.roofEnabled ?? ui.roofEnabled.checked;
        }
        if (data.assets?.base) {
          if (data.assets.base.unilateral) ui.uniBase.value = data.assets.base.unilateral;
          if (data.assets.base.bilateral) ui.biBase.value = data.assets.base.bilateral;
          if (data.assets.base.corner) ui.cornerBase.value = data.assets.base.corner;
          if (data.assets.base.trilateral) ui.triBase.value = normalizeTrilateralBase(data.assets.base.trilateral);
        }
        if (data.assets?.adjust) {
          state.assetAdjust = cloneAssetAdjust(data.assets.adjust);
        }
        const gen = new MapGenerator(data.width, data.height, {
          seed: data.meta?.seedSource ?? data.meta?.seed ?? null
        });
        gen.map = data.map;
        gen.meta = Object.assign(gen.meta || {
        }, data.meta || {
        });
        state.gen = gen;
        state.cellSize = parseNumber(ui.cellSize, 6, 0.2);
        state.wallHeight = Math.max(1, Math.round(parseNumber(ui.wallHeight, 1, 1, 50)));
        state.yawOffset = parseNumber(ui.yawOffset, 0, -360, 360);
        state.includeInner = ui.includeInner.checked;
        state.roofEnabled = ui.roofEnabled.checked;
        updateAssetConfig();
        updateTemplateUI();
        updateGoalUI();
        if (gen.meta) {
          ui.entranceX.value = gen.meta.entrance?.x ?? '';
          ui.entranceY.value = gen.meta.entrance?.y ?? '';
          ui.exitX.value = gen.meta.exit?.x ?? '';
          ui.exitY.value = gen.meta.exit?.y ?? '';
          ui.startX.value = gen.meta.start?.x ?? '';
          ui.startY.value = gen.meta.start?.y ?? '';
          ui.endX.value = gen.meta.end?.x ?? '';
          ui.endY.value = gen.meta.end?.y ?? '';
        }
        buildScene({
          resetCamera: true
        });
      }
      function downloadJson(filename, data) {
        const blob = new Blob([data], {
          type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }
      function calcAutoRoomAttempts(w, h) {
        const base = Math.round((w * h) / 2500);
        return Math.max(1, Math.min(200, base));
      }
      function currentBrushValue() {
        const v = Number(ui.roomBrush.value);
        return Number.isFinite(v) ? v : 1;
      }
      function fillTemplateRect(pad = 3) {
        templateData.fill(0);
        const x0 = Math.max(0, pad);
        const y0 = Math.max(0, pad);
        const x1 = Math.min(TEMPLATE_SIZE, TEMPLATE_SIZE - pad);
        const y1 = Math.min(TEMPLATE_SIZE, TEMPLATE_SIZE - pad);
        for (let y = y0;
        y < y1;
        y++) {
          for (let x = x0;
          x < x1;
          x++) {
            templateData[y * TEMPLATE_SIZE + x] = 1;
          }
        }
        renderTemplate();
      }
      function renderTemplate() {
        const size = TEMPLATE_SIZE;
        const cell = templateCanvas.width / size;
        templateCtx.clearRect(0, 0, templateCanvas.width, templateCanvas.height);
        templateCtx.fillStyle = '#b8bdc3';
        templateCtx.fillRect(0, 0, templateCanvas.width, templateCanvas.height);
        for (let y = 0;
        y < size;
        y++) {
          for (let x = 0;
          x < size;
          x++) {
            const v = templateData[y * size + x];
            if (!v) continue;
            templateCtx.fillStyle = TEMPLATE_COLORS[v] || '#ffffff';
            templateCtx.fillRect(x * cell, y * cell, cell, cell);
          }
        }
        templateCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        templateCtx.lineWidth = 1;
        for (let i = 0;
        i <= size;
        i++) {
          const p = i * cell;
          templateCtx.beginPath();
          templateCtx.moveTo(p, 0);
          templateCtx.lineTo(p, templateCanvas.height);
          templateCtx.stroke();
          templateCtx.beginPath();
          templateCtx.moveTo(0, p);
          templateCtx.lineTo(templateCanvas.width, p);
          templateCtx.stroke();
        }
      }
      function templateIndexFromEvent(e) {
        const rect = templateCanvas.getBoundingClientRect();
        const x = Math.floor(((e.clientX - rect.left) / rect.width) * TEMPLATE_SIZE);
        const y = Math.floor(((e.clientY - rect.top) / rect.height) * TEMPLATE_SIZE);
        if (x < 0 || y < 0 || x >= TEMPLATE_SIZE || y >= TEMPLATE_SIZE) return -1;
        return y * TEMPLATE_SIZE + x;
      }
      templateCanvas.addEventListener('pointerdown', (e) => {
        if (!ui.useRoomTemplate.checked) return;
        const idx = templateIndexFromEvent(e);
        if (idx < 0) return;
        templateDrawing = true;
        templateDrawValue = currentBrushValue();
        templateData[idx] = templateDrawValue;
        renderTemplate();
        templateCanvas.setPointerCapture(e.pointerId);
      });
      templateCanvas.addEventListener('pointermove', (e) => {
        if (!templateDrawing || !ui.useRoomTemplate.checked) return;
        const idx = templateIndexFromEvent(e);
        if (idx < 0) return;
        if (templateData[idx] !== templateDrawValue) {
          templateData[idx] = templateDrawValue;
          renderTemplate();
        }
      });
      templateCanvas.addEventListener('pointerup', (e) => {
        templateDrawing = false;
        templateCanvas.releasePointerCapture(e.pointerId);
      });
      templateCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
      function rotateMask(mask, steps) {
        let m = mask;
        for (let i = 0;
        i < steps;
        i++) {
          let next = 0;
          if (m & SIDE.N) next |= ROTATE_CW[SIDE.N];
          if (m & SIDE.E) next |= ROTATE_CW[SIDE.E];
          if (m & SIDE.S) next |= ROTATE_CW[SIDE.S];
          if (m & SIDE.W) next |= ROTATE_CW[SIDE.W];
          m = next;
        }
        return m;
      }
      function yawForMask(mask, baseMask, offset) {
        for (let k = 0;
        k < 4;
        k++) {
          if (rotateMask(baseMask, k) === mask) return (-k * 90) + offset;
        }
        return offset;
      }
      function isWall(map, w, h, x, y) {
        if (x < 0 || y < 0 || x >= w || y >= h) return false;
        return map[y * w + x] === CELL.WALL;
      }
      function wallMask(map, w, h, x, y) {
        const openN = !isWall(map, w, h, x, y - 1);
        const openS = !isWall(map, w, h, x, y + 1);
        const openW = !isWall(map, w, h, x - 1, y);
        const openE = !isWall(map, w, h, x + 1, y);
        let mask = 0;
        if (openN) mask |= SIDE.N;
        if (openE) mask |= SIDE.E;
        if (openS) mask |= SIDE.S;
        if (openW) mask |= SIDE.W;
        return {
          mask, openCount: (openN + openE + openS + openW)
        };
      }
      function baseMaskForCorner(label) {
        if (label === 'NE') return SIDE.N | SIDE.E;
        if (label === 'SE') return SIDE.S | SIDE.E;
        if (label === 'SW') return SIDE.S | SIDE.W;
        return SIDE.N | SIDE.W;
      }
      function parseTrilateralBase(value) {
        const raw = String(value ?? '').toUpperCase();
        let openMask = 0;
        if (raw.length === 1 && SIDE[raw]) {
          openMask = (SIDE.N | SIDE.E | SIDE.S | SIDE.W) & ~SIDE[raw];
        }
        else {
          for (const ch of raw) {
            if (SIDE[ch]) openMask |= SIDE[ch];
          }
        }
        if (!openMask) openMask = TRILATERAL_OPTIONS[1].open;
        const match = TRILATERAL_OPTIONS.find((opt) => opt.open === openMask);
        const label = match ? match.label : TRILATERAL_OPTIONS[1].label;
        return {
          openMask, closedMask: (SIDE.N | SIDE.E | SIDE.S | SIDE.W) & ~openMask, label
        };
      }
      function normalizeTrilateralBase(value) {
        return parseTrilateralBase(value).label;
      }
      function baseMaskForTrilateral(base) {
        return parseTrilateralBase(base).openMask;
      }
      function computeModelScale() {
        const assetSize = Math.max(0.01, state.assetSize);
        return (state.cellSize / assetSize) * state.wallScale;
      }
      function blockHeight() {
        return state.cellSize * state.wallScale;
      }
      function wallY() {
        const size = blockHeight();
        return state.assetOrigin === 'center' ? (size * 0.5) : 0;
      }
      function updateAssetConfig() {
        state.assetSize = parseNumber(ui.assetSize, 6, 0.1);
        state.wallScale = parseNumber(ui.wallScale, 1, 0.01);
        state.wallHeight = Math.max(1, Math.round(parseNumber(ui.wallHeight, 1, 1, 50)));
        state.assetOrigin = ui.assetOrigin.value || 'center';
        const uni = ui.uniBase.value || 'S';
        const bi = ui.biBase.value || 'NS';
        const corner = ui.cornerBase.value || 'SE';
        const tri = ui.triBase.value || 'NSE';
        state.assetBase = {
          unilateral: SIDE[uni] || SIDE.S,          bilateral: bi === 'EW' ? (SIDE.E | SIDE.W) : (SIDE.N | SIDE.S),          corner: baseMaskForCorner(corner),          trilateral: baseMaskForTrilateral(tri),
        };
        const scale = computeModelScale();
        ui.computedScale.textContent = scale.toFixed(3);
        renderAssetPreview();
      }
      function renderAssetPreview() {
        const ctx = assetPreviewCtx;
        const w = assetPreviewCanvas.width;
        const h = assetPreviewCanvas.height;
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#0f141d';
        ctx.fillRect(0, 0, w, h);
        const tiles = [          {
          label: 'U', mask: state.assetBase.unilateral
        },          {
          label: 'B', mask: state.assetBase.bilateral
        },          {
          label: 'C', mask: state.assetBase.corner
        },          {
          label: 'T', mask: state.assetBase.trilateral
        },          {
          label: 'F', mask: SIDE.N | SIDE.E | SIDE.S | SIDE.W
        },        ];
        const cols = 3;
        const rows = 2;
        const gap = 8;
        const tileW = Math.floor((w - gap * (cols + 1)) / cols);
        const tileH = Math.floor((h - gap * (rows + 1)) / rows);
        const size = Math.min(tileW, tileH);
        const openColor = '#34d399';
        const closedColor = '#374151';
        const fillColor = '#1b212b';
        tiles.forEach((tile, i) => {
          const col = i % cols;
          const row = Math.floor(i / cols);
          const x = gap + col * (size + gap);
          const y = gap + row * (size + gap);
          const pad = 10;
          const left = x + pad;
          const top = y + pad;
          const s = size - pad * 2;
          ctx.fillStyle = fillColor;
          ctx.fillRect(left, top, s, s);
          const openN = (tile.mask & SIDE.N) !== 0;
          const openE = (tile.mask & SIDE.E) !== 0;
          const openS = (tile.mask & SIDE.S) !== 0;
          const openW = (tile.mask & SIDE.W) !== 0;
          const drawEdge = (x1, y1, x2, y2, open) => {
            ctx.strokeStyle = open ? openColor : closedColor;
            ctx.lineWidth = open ? 4 : 2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          };
          drawEdge(left, top, left + s, top, openN);
          drawEdge(left + s, top, left + s, top + s, openE);
          drawEdge(left, top + s, left + s, top + s, openS);
          drawEdge(left, top, left, top + s, openW);
          ctx.fillStyle = '#e7e3d9';
          ctx.font = '12px "Space Grotesk", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.label, left + s / 2, top + s / 2);
          ctx.fillStyle = '#f7b32b';
          ctx.beginPath();
          ctx.moveTo(left + s / 2, top - 2);
          ctx.lineTo(left + s / 2 - 4, top + 6);
          ctx.lineTo(left + s / 2 + 4, top + 6);
          ctx.closePath();
          ctx.fill();
        });
      }
      function renderMinimap() {
        const gen = state.gen;
        if (!gen || !state.map) {
          minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
          return;
        }
        const w = state.width;
        const h = state.height;
        const cw = minimapCanvas.width;
        const ch = minimapCanvas.height;
        const img = minimapCtx.createImageData(cw, ch);
        const data = img.data;
        for (let y = 0;
        y < ch;
        y++) {
          const sy = Math.floor((y / ch) * h);
          const rowOff = sy * w;
          for (let x = 0;
          x < cw;
          x++) {
            const sx = Math.floor((x / cw) * w);
            const v = state.map[rowOff + sx];
            let c = MINIMAP_COLORS.path;
            if (v === CELL.WALL) c = MINIMAP_COLORS.wall;
            else if (v === CELL.ENTRANCE) c = MINIMAP_COLORS.entrance;
            else if (v === CELL.EXIT) c = MINIMAP_COLORS.exit;
            else if (v === CELL.START) c = MINIMAP_COLORS.start;
            else if (v === CELL.END) c = MINIMAP_COLORS.end;
            const o = (y * cw + x) * 4;
            data[o] = c[0];
            data[o + 1] = c[1];
            data[o + 2] = c[2];
            data[o + 3] = c[3];
          }
        }
        minimapCtx.putImageData(img, 0, 0);
        const drawMeta = (pos, color) => {
          if (!pos) return;
          const px = Math.floor((pos.x / w) * cw);
          const py = Math.floor((pos.y / h) * ch);
          minimapCtx.fillStyle = color;
          minimapCtx.fillRect(px - 2, py - 2, 5, 5);
        };
        const meta = gen.meta;
        if (meta) {
          drawMeta(meta.entrance, 'rgba(34,197,94,0.95)');
          drawMeta(meta.exit, 'rgba(249,115,22,0.95)');
          drawMeta(meta.start, 'rgba(96,165,250,0.95)');
          drawMeta(meta.end, 'rgba(239,68,68,0.95)');
        }
      }
      function modelFor(maskInfo, includeInner) {
        const {
          mask, openCount
        }
        = maskInfo;
        if (openCount === 0) return includeInner ? {
          id: '#mdl-full', yaw: 0, key: 'full'
        }
        : null;
        if (openCount === 1) return {
          id: '#mdl-unilateral', yaw: yawForMask(mask, state.assetBase.unilateral, 0), key: 'unilateral'
        };
        if (openCount === 2) {
          const straight = (mask === (SIDE.N | SIDE.S)) || (mask === (SIDE.E | SIDE.W));
          if (straight) return {
            id: '#mdl-bilateral', yaw: yawForMask(mask, state.assetBase.bilateral, 0), key: 'bilateral'
          };
          return {
            id: '#mdl-corner', yaw: yawForMask(mask, state.assetBase.corner, 0), key: 'corner'
          };
        }
        if (openCount === 3) return {
          id: '#mdl-trilateral', yaw: yawForMask(mask, state.assetBase.trilateral, 0), key: 'trilateral'
        };
        if (openCount === 4) return {
          id: '#mdl-full', yaw: 0, key: 'full'
        };
        return null;
      }
      function updateTemplateUI() {
        const enabled = ui.useRoomTemplate.checked;
        ui.roomTemplateWrap.classList.toggle('disabled', !enabled);
        ui.roomBrush.disabled = !enabled;
        ui.forceRoomTemplate.disabled = !enabled;
      }
      function updateGoalUI() {
        const isManual = ui.goalMode.value === 'manual';
        ui.manualGoals.classList.toggle('hidden', !isManual);
        if (ui.noBorders.checked) {
          ui.resetBorders.checked = false;
          ui.resetBorders.disabled = true;
        }
        else {
          ui.resetBorders.disabled = false;
        }
      }
      function parseCoordPair(xEl, yEl) {
        const x = Number(xEl.value);
        const y = Number(yEl.value);
        if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
        return {
          x: Math.round(x), y: Math.round(y)
        };
      }
      function addGoalMarker(pos, color, shape) {
        if (!pos) return;
        const cellSize = state.cellSize;
        const height = cellSize * 0.6;
        const y = height * 0.5;
        const wx = (pos.x * cellSize) - state.halfW;
        const wz = (pos.y * cellSize) - state.halfH;
        const el = document.createElement(shape === 'cylinder' ? 'a-cylinder' : 'a-sphere');
        if (shape === 'cylinder') {
          el.setAttribute('radius', cellSize * 0.22);
          el.setAttribute('height', height);
        }
        else {
          el.setAttribute('radius', cellSize * 0.3);
        }
        el.setAttribute('color', color);
        el.setAttribute('position', `${wx} ${y} ${wz}`);
        el.setAttribute('opacity', '0.9');
        goalsEl.appendChild(el);
      }
      function renderGoals(meta) {
        goalsEl.innerHTML = '';
        if (!meta) return;
        addGoalMarker(meta.entrance, '#22c55e', 'cylinder');
        addGoalMarker(meta.exit, '#f97316', 'cylinder');
        addGoalMarker(meta.start, '#60a5fa', 'sphere');
        addGoalMarker(meta.end, '#ef4444', 'sphere');
      }
      function buildScene({
        resetCamera = false
      }
      = {
      }) {
        const gen = state.gen;
        if (!gen) return;
        const map = gen.getMap();
        const w = gen.width;
        const h = gen.height;
        const cellSize = state.cellSize;
        const modelScale = computeModelScale();
        const yawOffset = state.yawOffset;
        const includeInner = state.includeInner;
        const yBase = wallY();
        const blockH = blockHeight();
        const wallSize = blockH * state.wallHeight;
        state.map = map;
        state.width = w;
        state.height = h;
        state.halfW = (w - 1) * cellSize * 0.5;
        state.halfH = (h - 1) * cellSize * 0.5;
        floorEl.setAttribute('width', w * cellSize);
        floorEl.setAttribute('height', h * cellSize);
        floorEl.setAttribute('position', '0 0 0');
        const roofThickness = blockH;
        roofEl.setAttribute('width', w * cellSize);
        roofEl.setAttribute('depth', h * cellSize);
        roofEl.setAttribute('height', roofThickness);
        roofEl.setAttribute('position', `0 ${wallSize + roofThickness * 0.5} 0`);
        roofEl.setAttribute('visible', state.roofEnabled ? 'true' : 'false');
        mazeEl.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let y = 0;
        y < h;
        y++) {
          for (let x = 0;
          x < w;
          x++) {
            if (map[y * w + x] !== CELL.WALL) continue;
            const maskInfo = wallMask(map, w, h, x, y);
            const model = modelFor(maskInfo, includeInner);
            if (!model) continue;
            const adjust = state.assetAdjust[model.key] || {
              pos: {
                x: 0, y: 0, z: 0
              }, rotY: 0, scale: 1
            };
            const baseYaw = model.yaw + yawOffset;
            const ox = adjust.pos?.x || 0;
            const oz = adjust.pos?.z || 0;
            const rad = baseYaw * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const rx = (ox * cos) + (oz * sin);
            const rz = (-ox * sin) + (oz * cos);
            const wx = (x * cellSize) - state.halfW + rx;
            const wz = (y * cellSize) - state.halfH + rz;
            const yaw = baseYaw + (adjust.rotY || 0);
            const scale = modelScale * (adjust.scale || 1);
            for (let layer = 0;
            layer < state.wallHeight;
            layer++) {
              const ent = document.createElement('a-entity');
              const wy = yBase + (adjust.pos?.y || 0) + (layer * blockH);
              ent.setAttribute('gltf-model', model.id);
              ent.setAttribute('position', `${wx} ${wy} ${wz}`);
              ent.setAttribute('rotation', `0 ${yaw} 0`);
              ent.setAttribute('scale', `${scale} ${scale} ${scale}`);
              frag.appendChild(ent);
            }
          }
        }
        mazeEl.appendChild(frag);
        renderGoals(gen.meta);
        renderMinimap();
        if (resetCamera) {
          let anchor = null;
          if (gen.meta?.start) anchor = gen.meta.start;
          else if (gen.meta?.entrance) anchor = gen.meta.entrance;
          if (anchor) {
            const sx = (anchor.x * cellSize) - state.halfW;
            const sz = (anchor.y * cellSize) - state.halfH;
            rigEl.setAttribute('position', `${sx} 1.6 ${sz}`);
          }
          else {
            rigEl.setAttribute('position', `0 1.6 ${Math.max(4, state.halfH)}`);
          }
        }
      }
      function applyGoals({
        resetCamera = false
      }
      = {
      }) {
        if (!state.gen) return;
        const gen = state.gen;
        const markCells = ui.markCells.checked;
        const allowSame = ui.allowSame.checked;
        const resetBorders = ui.resetBorders.checked && !ui.noBorders.checked;
        gen.clearGoalMarkers();
        try {
          const mode = ui.goalMode.value;
          if (mode === 'auto_all') {
            gen.autoPlaceGoals({
              markCells, allowSameAsEntranceExit: allowSame, resetBorders
            });
          }
          else if (mode === 'auto_entrance_exit') {
            gen.autoPlaceEntranceExit({
              markCells, resetBorders
            });
          }
          else if (mode === 'auto_start_end') {
            gen.autoPlaceStartEnd({
              markCells, allowSameAsEntranceExit: allowSame
            });
          }
          else {
            const entrance = parseCoordPair(ui.entranceX, ui.entranceY);
            const exit = parseCoordPair(ui.exitX, ui.exitY);
            const start = parseCoordPair(ui.startX, ui.startY);
            const end = parseCoordPair(ui.endX, ui.endY);
            if (resetBorders) gen.regenerateBorders();
            gen.setGoals({
              entrance, exit, start, end
            }, {
              markCells
            });
          }
        }
        catch (err) {
        }
        buildScene({
          resetCamera
        });
      }
      function clearGoals() {
        if (!state.gen) return;
        state.gen.clearGoalMarkers();
        buildScene({
          resetCamera: false
        });
      }
      function rebuildScene() {
        if (!state.gen) return;
        buildScene({
          resetCamera: false
        });
      }
      function generate() {
        const width = parseNumber(ui.width, 41, 5);
        const height = parseNumber(ui.height, 41, 5);
        const seed = parseSeed(ui.seed.value);
        const cellSize = parseNumber(ui.cellSize, 6, 0.2);
        const wallHeight = Math.max(1, Math.round(parseNumber(ui.wallHeight, 1, 1, 50)));
        const yawOffset = parseNumber(ui.yawOffset, 0, -360, 360);
        const gen = new MapGenerator(width, height, {
          seed
        });
        const attemptsInput = parseNumber(ui.roomAttempts, 0, 0, 2000);
        const attempts = attemptsInput > 0 ? attemptsInput : calcAutoRoomAttempts(gen.width, gen.height);
        gen.generateMaze({
          ensureBorderWalls: !ui.noBorders.checked,
          carveToBorder: ui.noBorders.checked
        });
        gen.applyRooms({
          attempts,          minSize: parseNumber(ui.roomMin, 3, 1),          maxSize: parseNumber(ui.roomMax, 9, 1),          template: ui.useRoomTemplate.checked ? templateData : null,          templateSize: TEMPLATE_SIZE,          forceTemplate: ui.forceRoomTemplate.checked,
        });
        if (ui.pacmanize.checked) {
          gen.pacmanizeMap();
        }
        state.gen = gen;
        state.cellSize = cellSize;
        state.wallHeight = wallHeight;
        state.yawOffset = yawOffset;
        state.includeInner = ui.includeInner.checked;
        state.roofEnabled = ui.roofEnabled.checked;
        updateAssetConfig();
        if (ui.goalMode.value !== 'manual') {
          applyGoals({
            resetCamera: true
          });
        }
        else {
          buildScene({
            resetCamera: true
          });
        }
      }
      ui.generate.addEventListener('click', generate);
      refreshWorldList();
      if (ui.worldList.value) ui.worldName.value = ui.worldList.value;
      ui.saveWorld.addEventListener('click', () => {
        const name = (ui.worldName.value || '').trim() || `world_${Date.now()}`;
        const snapshot = buildWorldSnapshot(name);
        if (!snapshot) {
          return;
        }
        const lib = loadWorldLibrary();
        lib[name] = snapshot;
        saveWorldLibrary(lib);
        refreshWorldList(name);
      });
      ui.loadWorld.addEventListener('click', () => {
        const name = ui.worldList.value;
        if (!name) return;
        const lib = loadWorldLibrary();
        const data = lib[name];
        if (!data) return;
        applyWorldSnapshot(data);
      });
      ui.deleteWorld.addEventListener('click', () => {
        const name = ui.worldList.value;
        if (!name) return;
        const lib = loadWorldLibrary();
        delete lib[name];
        saveWorldLibrary(lib);
        refreshWorldList();
      });
      ui.worldList.addEventListener('change', () => {
        ui.worldName.value = ui.worldList.value || '';
      });
      ui.exportWorld.addEventListener('click', () => {
        const name = (ui.worldName.value || '').trim() || ui.worldList.value || `world_${Date.now()}`;
        const snapshot = buildWorldSnapshot(name);
        if (!snapshot) {
          return;
        }
        const json = serializeWorld(snapshot, true);
        downloadJson(`${name}.json`, json);
      });
      ui.importWorld.addEventListener('change', (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const parsed = parseWorld(reader.result);
            applyWorldSnapshot(parsed);
            const name = parsed.name || `world_${Date.now()}`;
            const lib = loadWorldLibrary();
            lib[name] = parsed;
            saveWorldLibrary(lib);
            refreshWorldList(name);
          }
          catch (err) {
          }
        };
        reader.readAsText(file);
      });
      ui.goalMode.addEventListener('change', updateGoalUI);
      ui.applyGoals.addEventListener('click', () => applyGoals());
      ui.clearGoals.addEventListener('click', clearGoals);
      ui.noBorders.addEventListener('change', updateGoalUI);
      ui.useRoomTemplate.addEventListener('change', updateTemplateUI);
      ui.roomClear.addEventListener('click', () => {
        templateData.fill(0);
        renderTemplate();
      });
      ui.roomFill.addEventListener('click', () => {
        const v = currentBrushValue();
        templateData.fill(v);
        renderTemplate();
      });
      ui.roomInvert.addEventListener('click', () => {
        for (let i = 0;
        i < templateData.length;
        i++) {
          templateData[i] = templateData[i] ? 0 : 1;
        }
        renderTemplate();
      });
      ui.roomRect.addEventListener('click', () => fillTemplateRect(3));
      ui.roomBrush.addEventListener('change', () => {
        templateDrawValue = currentBrushValue();
      });
      ui.includeInner.addEventListener('change', () => {
        state.includeInner = ui.includeInner.checked;
        buildScene({
          resetCamera: false
        });
      });
      ui.cellSize.addEventListener('input', () => {
        state.cellSize = parseNumber(ui.cellSize, 6, 0.2);
        updateAssetConfig();
        rebuildScene();
      });
      ui.wallHeight.addEventListener('input', () => {
        state.wallHeight = Math.max(1, Math.round(parseNumber(ui.wallHeight, 1, 1, 50)));
        updateAssetConfig();
        rebuildScene();
      });
      ui.yawOffset.addEventListener('input', () => {
        state.yawOffset = parseNumber(ui.yawOffset, 0, -360, 360);
        rebuildScene();
      });
      ui.roofEnabled.addEventListener('change', () => {
        state.roofEnabled = ui.roofEnabled.checked;
        rebuildScene();
      });
      [ui.assetSize, ui.wallScale].forEach((el) => {
        el.addEventListener('input', () => {
          updateAssetConfig();
          rebuildScene();
        });
      });
      [ui.assetOrigin, ui.uniBase, ui.biBase, ui.cornerBase, ui.triBase].forEach((el) => {
        el.addEventListener('change', () => {
          updateAssetConfig();
          rebuildScene();
        });
      });
      fillTemplateRect(3);
      updateTemplateUI();
      updateGoalUI();
      const storedCfg = loadCalibrationConfig();
      if (!applyCalibrationConfig(storedCfg)) {
        updateAssetConfig();
      }
      generate();
    </script>
  </body>
</html>
